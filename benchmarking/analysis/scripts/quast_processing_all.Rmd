---
title: "Ecoli_plasmid_reconstruction_Benchmark"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_knit$set(echo = TRUE)
```

Load packages
```{r}
require(readr)
require(tidyr)
require(dplyr)
require(magrittr)
require(ggplot2)
require(stringr)

```

Use a nice theme for ggplot
```{r, include=FALSE}
theme_set(theme_bw())
```

## Script for processing QUAST output

Get a list of all replicons, with their references_id and the lengths
```{r}
replicon_data <- read.csv("../../../Ecoli_ncbi_download/results/replicon_data.csv", header = FALSE)
names(replicon_data)<-c('strain','reference_id','replicon_length','classification')
```

Import and process the results from QUAST

I defined a function for importing the MOB-suite results because I needed to execute the same code many times:
```{r}
import_quast_mob <- function(mode) {
  path<-paste0('../../plasmid_reconstruction/results/Ecoli/quast_statistics/',mode,'/',mode,'_alignments_statistics.csv')
  df<-read.csv(path, sep=',', header=FALSE)
  names(df)<-c('strain','bin_name_temp','reference_id','alignment_length','bin_length')
  df %<>% mutate(software = mode)
  #For MOB-suite we will fuse the name of the bin with the name of the strain, to be able to do statistics   properly
  df<-unite(df,'bin_name',c('strain','bin_name_temp'),remove=FALSE) 
  #remove old bin name
  df<-df[,c(2,1,4:7)]
  return(df)
}
```

Run the function for all mobsuite modes:
```{r}
modes <- c("mob_uni","mob_unitrim","mob_bac","mob_uni_cleaned","mob_uni_filtered","mob_bac_cleaned","mob_bac_filtered")

for (mode in modes){
  #import quast results
  quast_out <- import_quast_mob(mode)
  #rename the dataframe
  name <- paste0("quast_output_",mode)
  assign(name,quast_out)
}

```

Import PlasmidSPAdes results:
```{r}
#SPADES
quast_output_spades<-read.csv('../../plasmid_reconstruction/results/Ecoli/quast_statistics/spades/spades_alignments_statistics.csv', sep = ',', header = FALSE)
names(quast_output_spades)<-c('strain','bin_name','reference_id','alignment_length','bin_length')
quast_output_spades %<>% mutate(software = "spades")
```

Combine all quast output and cross with replicon data
```{r}
quast_output_all<-rbind(quast_output_mob_bac,quast_output_mob_bac_cleaned,quast_output_mob_bac_filtered,quast_output_mob_uni,quast_output_mob_uni_cleaned,quast_output_mob_uni_filtered,quast_output_mob_unitrim,quast_output_spades)
quast_output_plasmids_chromosomes<-full_join(replicon_data,quast_output_all,by=c('strain','reference_id'))
```

For all bins that align to a plasmid, we calculate the recall (percentage of plasmid bps included in the bin) and precision (percentage of bps in the bin that are plasmid derived).


### Calculating Precision
For calculating precision correctly, we will have to substract the exceeding multiple alignments lengths. (otherwise, total alignment could be larger than the bin-length, therefore precision could be larger than 1, and that is not possible) 

To achieve this, we will first obtain how many times each contig aligns to the replicon (n), then we would substract one from that number (n-1) and finally we will substract (n-1)*contig_length from the alignment length for those specific cases.

n, and contig_length can be obtained from the files 'mob_ambiguous_references', which was an output from the 'gather_quast_results.py script'

Import Ambiguous alignment information and wrangle the data
```{r}
import_ambiguous_alignments_mob <- function(mode){
  path <- paste0('../../plasmid_reconstruction/results/Ecoli/quast_statistics/',mode,'/',mode,'_ambiguous_references.csv')
  df<-read.csv(path, sep=',', header=FALSE)
  names(df)<-c('strain','bin_name_temp','reference_id','contig_name','contig_length','start','end')
  df<-unite(df,'bin_name',c('strain','bin_name_temp'),remove=FALSE) 
  #remove old bin name
  df<-df[,c(1,2,4:8)]
  df$software<-mode
  return(df)
}
```

```{r}
modes <- c("mob_uni","mob_unitrim","mob_bac","mob_uni_cleaned","mob_uni_filtered","mob_bac_cleaned","mob_bac_filtered")

for (mode in modes){
  #import quast results
  amb_out <- import_ambiguous_alignments_mob(mode)
  #rename the dataframe
  name <- paste0("ambiguous_alignments_",mode)
  assign(name,amb_out)
}
```

```{r}
#spades
ambiguous_alignments_spades<-read.csv('../../plasmid_reconstruction/results/Ecoli/quast_statistics/spades/spades_ambiguous_references.csv', sep=',', header=FALSE)
names(ambiguous_alignments_spades)<-c('strain','bin_name','reference_id','contig_name','contig_length','start','end')
ambiguous_alignments_spades$software<-'spades'
```


```{r, warning=FALSE, fig.width=14, fig.height=18}
#merge files of different softwares
ambiguous_alignments_total<-rbind(ambiguous_alignments_mob_bac,ambiguous_alignments_mob_bac_cleaned,ambiguous_alignments_mob_bac_filtered,ambiguous_alignments_mob_uni,ambiguous_alignments_mob_uni_cleaned,ambiguous_alignments_mob_uni_filtered,ambiguous_alignments_mob_unitrim,ambiguous_alignments_spades)

#remove duplications of the same ambiguous contig being included twice
ambiguous_alignments_total<-unique(ambiguous_alignments_total)

#count how many times each contig ambiguously aligns to the same replicon (n)
count_ambiguous_alignments_to_same_replicon<- ambiguous_alignments_total %>% group_by(strain,bin_name,reference_id,contig_name,software) %>% summarise(total_ambiguous_alignments=n(),ambiguous_alignment=sum(contig_length))

#join this information with the ambiguous_alignments
all_ambiguous_alignments<-inner_join(ambiguous_alignments_total,count_ambiguous_alignments_to_same_replicon,by=c('strain','bin_name','reference_id','contig_name','software'))

#filter out the start and end column
all_ambiguous_alignments<-all_ambiguous_alignments[,-c(6,7)]
```


```{r, warning=FALSE, fig.width=14, fig.height=18}
#the problem here is that we have several entries that have a slightly different contig lenght. We will calculate the median
all_ambiguous_alignments %<>% group_by(strain,bin_name,reference_id,contig_name,software) %>% mutate(contig_length=round(median(contig_length))) %>% ungroup()
#keep only unique rows
all_ambiguous_alignments %<>% unique()

#get the total substraciton contigs (n-1)
all_ambiguous_alignments$substraction_times<-all_ambiguous_alignments$total_ambiguous_alignments-1

#now get the length that we will have to substract
all_ambiguous_alignments$ambiguous_substraction_length<-all_ambiguous_alignments$contig_length*all_ambiguous_alignments$substraction_times

#now we will sum all ambiguous substraction lengths that belong to the same bin_name/refrence_id (because there might be multiple contigs within the same bin that align to the same replicon)
all_ambiguous_alignments_final_substracion_data<-all_ambiguous_alignments %<>% group_by(strain,bin_name,reference_id,software) %>% summarise(total_substraction_length=sum(ambiguous_substraction_length),total_ambiguous_length=sum(ambiguous_alignment))
```

If the ONLY alignment of a bin to a replicon is ambiguous, this alignment does not count!
A bin which includes a repeated element might map to a replicon by only this repeated element. This makes it seems like it merges replicons together, while this isn't the case!

```{r, warning=FALSE, fig.width=14, fig.height=18}
#2.---- Cross information with the 'quast_output_plasmids_chromosomes' from previous section (this will allow us to calculate precision) ------
quast_output_plasmids_chromosomes<-left_join(quast_output_plasmids_chromosomes,all_ambiguous_alignments_final_substracion_data,by=c('strain','bin_name','reference_id','software'))
#replace NA values with 0 in the total_substraction_length (for cases in which there are no multiple alignments)
quast_output_plasmids_chromosomes$total_substraction_length[is.na(quast_output_plasmids_chromosomes$total_substraction_length)]<-0
quast_output_plasmids_chromosomes$total_ambiguous_length[is.na(quast_output_plasmids_chromosomes$total_ambiguous_length)]<-0

#Calculate the non-ambiguous length.
#I noticed that sometimes the non-ambiguous length is negative, which shouldn't happen. The ambiguous alignments don't overlap completely with the alignment length in the alignment statistics file, probably a bug in the gather_quast_results script. In one case there was a contig included in the ambiguous file but not in the alignment statistics file.
#Because it was very infrequent, I removed alignments with non-ambiguous length >= 0.
quast_output_plasmids_chromosomes %<>% mutate(non_ambiguous_length=alignment_length-total_ambiguous_length)
#Remove fully ambiguous bin-replicon associations
quast_output_plasmids_chromosomes %<>% filter(non_ambiguous_length > 0 | alignment_length == 0)

#2.1 Substract 'full alignment length' with 'multiple alignment length' to get the 'alignment length' that will be used for precision calculation
quast_output_plasmids_chromosomes$alignment_length_precision<-(quast_output_plasmids_chromosomes$alignment_length-quast_output_plasmids_chromosomes$total_substraction_length)

```

```{r}
#Filter replicons classified as plasmids
quast_output_plasmids<-filter(quast_output_plasmids_chromosomes,classification=='plasmid')
#For cases in which the bin_name was not present, this means that the tool did not detected this plasmid. Assign that category.
quast_output_plasmids$bin_name<-ifelse(is.na(quast_output_plasmids$bin_name),"not_detected",as.character(quast_output_plasmids$bin_name))
#For this cases also assign an alignment length =0
quast_output_plasmids$alignment_length[is.na(quast_output_plasmids$alignment_length)]<-0
#assign not applicable to all the rest of NA
quast_output_plasmids[is.na(quast_output_plasmids)]<-'not_applicable'

```

### Calculating Recall
```{r}
quast_output_plasmids$recall_bp<-as.numeric(quast_output_plasmids$alignment_length)/as.numeric(quast_output_plasmids$replicon_length)
```

Now assign a 'not detected' category for recall=0 (to exclude this values from calculations
```{r}
quast_output_plasmids$recall_bp<-ifelse(quast_output_plasmids$recall_bp==0,'not_detected',as.numeric(quast_output_plasmids$recall_bp))
```

```{r}
#3. ------- Calculate precision
quast_output_plasmids$precision_bp<-as.numeric(quast_output_plasmids$alignment_length_precision)/as.numeric(quast_output_plasmids$bin_length)

#format the data and round the results
quast_output_plasmids$precision_bp<-as.numeric(quast_output_plasmids$precision_bp)
quast_output_plasmids$recall_bp<-as.numeric(quast_output_plasmids$recall_bp)
quast_output_plasmids$recall_bp<-round(quast_output_plasmids$recall_bp,3)
quast_output_plasmids$precision_bp<-round(quast_output_plasmids$precision_bp,3)


#4 --- Calculate f1-score
quast_output_plasmids$f1_score<-round(2*((quast_output_plasmids$precision_bp*quast_output_plasmids$recall_bp)/(quast_output_plasmids$precision_bp+quast_output_plasmids$recall_bp)),3)

#convert NA to 0 for scores
quast_output_plasmids[is.na(quast_output_plasmids)]<-0

```



Analyse how many bins are aligned to either plasmid, chromosome, plasmid and chromosome or not aligned at all.
```{r}
bin_analysis <- quast_output_plasmids_chromosomes %>% filter(!is.na(bin_name)) %>% group_by(software) %>% mutate(multiple_replicons=duplicated(bin_name) | duplicated(bin_name, fromLast = TRUE))
bin_analysis %<>% mutate(bin_type=ifelse(multiple_replicons==FALSE & classification=="chromosome","chromosome",NA))
bin_analysis %<>% mutate(bin_type=ifelse(multiple_replicons==FALSE & classification=="plasmid","one_plasmid",bin_type))
bin_analysis %<>% group_by(software,bin_name) %>% mutate(bin_type=ifelse(multiple_replicons==TRUE & n_distinct(classification)==1,"multiple_plasmids",bin_type))
bin_analysis %<>% group_by(software,bin_name) %>% mutate(bin_type=ifelse(multiple_replicons==TRUE & n_distinct(classification)!=1 & n()==2,"plasmid_and_chromosome",bin_type))
bin_analysis %<>% group_by(software,bin_name) %>% mutate(bin_type=ifelse(multiple_replicons==TRUE & n_distinct(classification)!=1 & n()!=2,"multiple_plasmids_and_chromosome",bin_type))
bin_analysis %<>% mutate(bin_type=ifelse(reference_id=="no_correct_alignments" | reference_id== "contig_length_below_1k","no_correct_alignments",bin_type))

bin_analysis %<>% ungroup()
count_bin_types <- bin_analysis %>% select(bin_name,software,bin_type) %>% unique()
```


```{r}
ggplot(count_bin_types %>% filter(software %in% c("MOB-suite (unicycler, trimmed)","MOB-suite (unicycler)","MOB-suite (bactofidia)","PlasmidSPAdes")),aes(y=software,fill=factor(bin_type,level = rev(level_order_types))))+
  geom_bar(position = 'stack')+
  labs(x = "Number of bins",fill="Legend")+
  scale_fill_manual(values=rev(c("#75C24B","#47954D","#fc8e13","#ec6b3b","#e84141","#5c5d5f")),labels=rev(c("One plasmid","Multiple plasmids","Plasmid and chromosome","Multiple plasmids and chromosome","Chromosome","No correct alignments")),guide = guide_legend(reverse = TRUE))+
  labs(title="Bin composition per reconstruction method")+
  theme(axis.title.y = element_blank())
```

```{r}
ggsave("binnumber_initial.png",width = 8,height = 4)
```


What's up with the increase in plasmid/chromosome mixed bins when using the ensemble classifier?
```{r}
multiple_plasmids <- count_bin_types %>% filter(software=="MOB-suite (bactofidia, cleaned)" | software=="MOB-suite (bactofidia, plasmid contigs)") %>% filter(bin_type=="multiple_plasmids" )
write.csv(multiple_plasmids,"../results/multiple_plasmids.csv",row.names = FALSE)
```

Composition of mixed bins
```{r}
mixed_bin_analysis <- bin_analysis %>% filter(classification=="chromosome") #& multiple_replicons==TRUE)
#mixed_bin_analysis %<>% left_join(multiple_ambiguous_alignments_final_substracion_data,by=c('strain','bin_name','reference_id','software'))
#replace NA values with 0 in the total_substraction_length (for cases in which there are no multiple alignments)
mixed_bin_analysis$total_substraction_length[is.na(mixed_bin_analysis$total_substraction_length)]<-0

#update alignment length
mixed_bin_analysis %<>% mutate(actual_alignment_length=alignment_length-total_substraction_length)
mixed_bin_analysis %<>% mutate(chromosomal_content=actual_alignment_length/bin_length*100)
```

```{r}
ggplot(mixed_bin_analysis,aes(x=chromosomal_content,fill=bin_type))+
  geom_histogram(binwidth = 5,breaks= seq(0,100,by=5))+
  scale_x_continuous(breaks= seq(0,100,by=20))+
  facet_wrap(~software)
```
Find out whether a reference plasmid was predicted by the four methods, and whether it was split over bins.

```{r}
bin_number_plotting<-quast_output_plasmids %>% group_by(reference_id) %>% count(software)
not_detected<-quast_output_plasmids %>% filter(software=='not_applicable') %>% select(reference_id) %>% uncount(4)
not_detected %<>% mutate(software = rep(c("MOB-suite (bactofidia)","MOB-suite (unicycler, trimmed)","MOB-suite (unicycler)","PlasmidSPAdes"),times=nrow(not_detected)/4)) %>% mutate(n = 0)
bin_number_plotting<-rbind(bin_number_plotting,not_detected)
bin_number_plotting %<>% spread(software,n) %>% select(!not_applicable)
bin_number_plotting[is.na(bin_number_plotting)]<-0
bin_number_plotting %<>% gather('software','n',2:5)
bin_number_plotting %<>% mutate(correct=n==1)
```

```{r}
ggplot(bin_number_plotting,aes(x=reference_id,y=n,group=1,colour=correct))+
  geom_point(alpha=0.4)+
  facet_wrap(~software)+
  scale_y_continuous(breaks= seq(0,10,by=2))+
  guides(colour=FALSE)+
  scale_x_discrete(labels=NULL,breaks=NULL)
```

Some plotting
```{r}
length_data <- replicon_data %>% filter(classification=="plasmid")
ggplot(length_data,aes(x=log(replicon_length,10)))+geom_histogram(binwidth = 0.05)
```

```{r}
plotting_data <- filter(quast_output_plasmids ,!software %in% c("not_applicable"))
level_order_softwares=c("MOB-suite (bactofidia)","MOB-suite (bactofidia, cleaned)","MOB-suite (bactofidia, plasmid contigs)","MOB-suite (unicycler)","MOB-suite (unicycler, cleaned)","MOB-suite (unicycler, plasmid contigs)")
plotting_data$software = str_wrap(plotting_data$software, width=18)
ggplot(plotting_data,aes(x=software,y=f1_score)) +geom_boxplot() +geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.5)+
labs(title = "F1 score per plasmid containing bin")
```
```{r}
ggsave("f1_final.png",width = 7, height = 4)
```


```{r}
ggplot(plotting_data,aes(x=software,y=precision_bp)) +geom_boxplot(outlier.shape = NA) +geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.5)+
labs(title = "Precision per plasmid containing bin")
```
```{r}
ggsave("precision_final.png",width = 7, height = 4)
```
```{r}
ggplot(plotting_data,aes(x=software,y=recall_bp)) +geom_boxplot(outlier.shape = NA) +geom_jitter(alpha=0.5,shape=16, position=position_jitter(0.2))+
labs(title = "Recall per plasmid containing bin")
```
```{r}
ggsave("recall_final.png",width = 7, height = 4)
```
```{r}
ggplot(plotting_data,aes(x=recall_bp,y=precision_bp)) +
  geom_count(alpha=0.3) +
  scale_size_continuous(range = c(1.5,5)) +
  facet_wrap(~software)
```