---
title: "Binary classifier benchmarking study"
author: "Lisa"
date: "10/06/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,fig.width = 9,fig.align = "left")
```

```{r, include=FALSE}
require(readr)
require(magrittr)
require(dplyr)
require(ggplot2)
require(stringr)
require(tidyr)
require(knitr)
require(ggrepel)
require(VennDiagram)
require(RColorBrewer)
require(tibble)
require(venn)
```

```{r, include=FALSE}
theme_set(theme_bw())
```

### Introduction
This script is used to test the performance of four binary classifiers (Mlplasmids,Platon,Plascope and RFPlasmid) that were developed to differentiate chromosomal contigs from plasmidal contigs. We want to evaluate their performance specifically for E. coli ST131 strains. We use a benchmarking dataset of 50 ST131 samples that have been sequenced by short-read as well as long-read technologies, and that have their complete genomes. We have previously assembled the short reads of all samples and used the resulting contigs as input for the four binary classifiers. These contigs have also been mapped to their reference genomes by QUAST so that we know whether they belong to the chromosome or the plasmid. Now we will assess for each contig whether the prediction made by the binary classifiers matches the actual classification.


### Import contig related data##
Import replicon data.  
This file contains the classifications (chromosome or plasmid) for all replicons in our dataset.
```{r}
replicon_data <- read.csv("../../../ST131_ncbi_download/results/replicon_data.csv", header = FALSE)
names(replicon_data)<-c('assembly_accession','replicon_name','replicon_length','classification')
```

Import all contig names.  
The full list of all contigs in our dataset.
```{r}
all_contigs <- read.csv("../../../ST131_ncbi_download/results/shortread_assemblies_bactofidia/all_contig_names.txt", header = FALSE)
names(all_contigs)="contig_name"
all_contigs %<>% mutate(contig_name=str_replace(contig_name,'>',''))
```

Import quast information.  
Quast has been used to align the contigs to one of the replicons in the reference genome. However, not all contigs could be fully aligned to one replicon. We will select only those contigs for which we are confident that they belong to a certain replicon.  

The quast output file we import here contains the lines in the all_alignments files for which best_group is true (this includes all strains).  
We do some preprocessing of the output file:  
* Assess whether contigs appear multiple times (are duplicated)  
* Extract contig length from contig name  
* Convert start, end and contig length columns to integer type instead of character  
* Calculate the alignment length by substracting S2 (start of contig) from E2 (end of contig). (A one is added to compensate for the starting base that is also substracted, while it should be included in the alignment length)  

```{r,message=FALSE,warning=FALSE}
quast_out <- read_tsv("../../../ST131_ncbi_download/results/bactofidia_all_true_alignments.tsv", col_names = c("S1","E1","S2","E2","replicon_name","contig_name","identity","ambiguous","best_group"))
quast_out %<>% mutate(duplicated = duplicated(contig_name) | duplicated(contig_name, fromLast = TRUE))
quast_out %<>% separate(contig_name,into=c(NA,NA,NA,NA,"contig_length",sep='_'),remove = FALSE) %>% select(!"_")
quast_out %<>% mutate_each_(funs(as.integer), c("S1","E1","S2","E2","contig_length")) 
quast_out %<>% mutate(alignment_length=abs(S2-E2)+1)
```
### Contig selection
Make groups based on type of contig.  
If a contig only appears in the output file once, this means it only aligns to one part of the reference, and it is correctly aligned.  
Ambiguously aligned contigs are called based on the ambiguous column in the output file.  
Contigs that have another issue (misassemblies such as relocations, inversions, translocations and local misassemblies, or fake misassemblies) appear multiple times and are not ambiguous.

```{r}
correct_contigs <- quast_out %>% filter(duplicated=="FALSE")
ambiguous_contigs <- quast_out %>% filter(ambiguous=="TRUE")
other_contigs <- quast_out %>% filter(duplicated=="TRUE" & is.na(ambiguous))
```

For each group we will perform a separate contig selection.  

For correctly aligned contigs, we simply calculate the percentage aligned by dividing the alignment length by the contig length.  
Only contigs that have an alignment of 90% or more are kept. 
```{r}
correct_contigs %<>% mutate(percentage_aligned=alignment_length/contig_length*100)
failed_contigs <- correct_contigs %>% filter(percentage_aligned < 90) %>% select(contig_name,replicon_name) %>% mutate(contig_type="failed_threshold")
correct_contigs %<>% filter(percentage_aligned >= 90) %>% select(contig_name,replicon_name) %>% mutate(contig_type="correctly_aligned")
```


Ambiguously aligned contigs are categorised according to the nr. of replicons they align to.  
Contigs that only map to one replicon and have an alignment of at least 90% are always kept.  
Contigs that map to multiple replicons are only kept if these replicons are all plasmids and if they have an alignment of at least 90%.
```{r}
ambiguous_contigs %<>% mutate(percentage_aligned=alignment_length/contig_length*100)
ambiguous_contigs %<>% group_by(contig_name) %>% mutate(multiple_replicons = n_distinct(replicon_name))
failed_contigs <- rbind(failed_contigs,ambiguous_contigs %>% filter(percentage_aligned < 90)  %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="failed_threshold"))
ambiguous_contigs_one <- ambiguous_contigs %>% filter(multiple_replicons==1 & percentage_aligned >= 90) %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="ambiguously_aligned_one_replicon")
ambiguous_contigs_multiple <- ambiguous_contigs %>% filter(multiple_replicons!=1 & percentage_aligned >= 90)
ambiguous_contigs_multiple %<>% left_join(replicon_data,by="replicon_name") %>% group_by(contig_name) %>% mutate(multiple_classifications = n_distinct(classification))
ambiguous_contigs_multiple_good <- ambiguous_contigs_multiple %>% filter(multiple_classifications==1) %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="ambiguously_aligned_only_plasmid")
ambiguous_contigs_multiple_bad <- ambiguous_contigs_multiple %>% filter(multiple_classifications!=1) %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="ambiguously_aligned_both")
```

(Supposedly) misassembled contigs have different parts of the contig aligning to different regions of the reference.  
For these contigs, the total alignment length is calculated by summing all alignment lengths of a contig.  
This 'actual' alignment length is used for calculation of the alignment percentage.  
Again, contigs are kept if they only only map to one replicon or map to multiple plasmids and if they have an alignment of at least 90%.  

```{r}
other_contigs %<>% group_by(contig_name) %>% mutate(total_alignment_length=sum(alignment_length))
other_contigs %<>% mutate(percentage_aligned=total_alignment_length/contig_length*100)
other_contigs %<>% group_by(contig_name) %>% mutate(multiple_replicons = n_distinct(replicon_name))
failed_contigs <- rbind(failed_contigs,other_contigs %>% filter(percentage_aligned < 90)  %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="failed_threshold"))
other_contigs_one <- other_contigs %>% filter(multiple_replicons==1 & percentage_aligned >= 90) %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="other_issue_one_replicon")
other_contigs_multiple <- other_contigs %>% filter(multiple_replicons!=1 & percentage_aligned >= 90)
other_contigs_multiple %<>% left_join(replicon_data,by="replicon_name") %>% group_by(contig_name) %>% mutate(multiple_classifications = n_distinct(classification))
other_contigs_multiple_good <- other_contigs_multiple %>% filter(multiple_classifications==1) %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="other_issue_only_plasmid")
other_contigs_multiple_bad <- other_contigs_multiple %>% filter(multiple_classifications!=1) %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="other_issue_both")
```

All accepted contigs are grouped together.
```{r}
selected_contigs <- rbind(correct_contigs,ambiguous_contigs_one,ambiguous_contigs_multiple_good,other_contigs_one,other_contigs_multiple_good)
```

Right now ambiguously aligned contigs and other contigs that are mapped to multiple replicons appear in the dataset twice.  
To prevent this, we remove contig names that are duplicated.

```{r}
selected_contigs %<>% mutate(duplicated=duplicated(contig_name))
selected_contigs %<>% filter(duplicated==FALSE) %>% select(!duplicated)
```

An overview of all contigs.  
All previously evaluated contigs were mapped at least partly to the reference. There are also contigs that couldn't be mapped at all, either because they're smaller than the cutoff length used (1000 bp) or due to misassemblies.
Unmapped contigs are those contig names that do not appear in the mapped dataset.

```{r}
mapped_contigs <- rbind(selected_contigs,ambiguous_contigs_multiple_bad,other_contigs_multiple_bad,failed_contigs)
mapped_contigs %<>% mutate(duplicated=duplicated(contig_name)) %>% filter(duplicated==FALSE) %>% select(!duplicated)
unmapped_contigs <- filter(all_contigs,!contig_name %in% mapped_contigs$contig_name) %>% mutate(contig_type="unmapped",replicon_name=NA)
contig_type_overview <- rbind(mapped_contigs,unmapped_contigs)
```

The relative frequency and length distribution of contig types. Selected contigs are coloured, discarded contigs in greyscale. Misassemblies also include fake misassemblies.  

```{r, echo=FALSE}
level_order_contigs <- c("correctly_aligned","ambiguously_aligned_one_replicon","ambiguously_aligned_only_plasmid","other_issue_one_replicon","other_issue_only_plasmid","unmapped","failed_threshold","ambiguously_aligned_both","other_issue_both")
ggplot(contig_type_overview %>% count(contig_type),aes(x="",y=n,fill=factor(contig_type,level = rev(level_order_contigs))))+
  geom_bar(width = 1,stat = "identity")+
  coord_polar("y",start=0)+
  scale_fill_manual(labels=rev(c("Correctly aligned","Ambiguously aligned to one replicon","Ambiguously aligned to multiple plasmids","Misassembled and aligned to one replicon","Misassembled and aligned to multiple plasmids","Unaligned","Alignment less than 90% of contig size","Ambiguously aligned to both plasmid and chromosome","Misassembled and aligned to both plasmid and chromosome")),values=rev(c("#ffa600","#ff6361","#bc5090","#58508d","#003f5c","#bcbcbc","#8b8b8c","#5c5d5f","#323335")))+
  #geom_label_repel(aes(label = n), size=3, position = position_stack(vjust = 0.5))+
  labs(title = "Relative frequency of contig types",x = "",y = "Count",fill="Contig type")+
  guides(fill=guide_legend(reverse = TRUE))

```
  
```{r, echo=FALSE,warning=FALSE,message=FALSE}
contig_type_overview %<>% separate(contig_name,into=c("1","2","3","4","contig_length",sep='_'),remove=FALSE) %>% select(!c("1","2","3","4","_"))
ggplot(contig_type_overview,aes(x=log(as.numeric(contig_length),10),fill=factor(contig_type,level = level_order_contigs)))+
  geom_histogram()+
  scale_fill_manual(labels=c("Correctly aligned","Ambiguously aligned to one replicon","Ambiguously aligned to multiple plasmids","Misassembled and aligned to one replicon","Misassembled and aligned to multiple plasmids","Unaligned","Alignment less than 90% of contig size","Ambiguously aligned to both plasmid and chromosome","Misassembled and aligned to both plasmid and chromosome"),values=c("#ffa600","#ff6361","#bc5090","#58508d","#003f5c","#bcbcbc","#8b8b8c","#5c5d5f","#323335"))+
  labs(title = "Length distribution of contig types",x="Contig length (log10 bp)",y = "Count",fill="Contig type")
```
  
57% of all contigs could be correctly mapped to a replicon.  
27% could not be aligned at all, most of them being smaller than 1000 bp.  
6% of contigs were ambiguously aligned, mostly to only one replicon.   
9% of contigs had some kind of (supposed) misassembly event going on, almost all of them within the same replicon.  
1% of contigs were discarded because the contig had an alignment of less than 90%.  
Ambiguously aligned contigs appear to be short, while 'misassembled' contigs are longer.  

Add classifications to the replicons of selected contigs.
```{r}
selected_contig_info <- full_join(selected_contigs,replicon_data,by="replicon_name")
```

### Import binary classifier output
Mlplasmids
```{r,message=FALSE}
mlplasmids_out <- read_tsv("../../mlplasmids/results/mlplasmids_all_results.tsv")
names(mlplasmids_out)<-c('assembly_accession','sra_accession','prob_chromosome','prob_plasmid','prediction','contig_name','contig_length')
mlplasmids_out$prediction %<>% tolower()
mlplasmids_out %<>% mutate(software="mlplasmids")
#no_prediction_mlplasmids <- all_contigs %>% filter(!contig_name %in% mlplasmids_out$contig_name) %>% mutate(prediction="no prediction",software="mlplasmids")
```

Platon
```{r}
platon_out <- read.csv("../../platon/results/platon_all_results.csv", header = FALSE)
names(platon_out) <- c("contig_name","prediction")
platon_out %<>% mutate(contig_name=str_replace(contig_name,'>',''))
platon_out %<>% mutate(software="platon")
#no_prediction_platon <- all_contigs %>% filter(!contig_name %in% platon_out$contig_name) %>% mutate(prediction="no prediction",software="platon")
```

Plascope
```{r}
plascope_out <- read.csv("../../plascope/results/plascope_all_results.csv", header = FALSE)
names(plascope_out) <- c("contig_name","prediction")
plascope_out %<>% mutate(contig_name=str_replace(contig_name,'>',''))
plascope_out %<>% mutate(software="plascope")
#no_prediction_plascope <- all_contigs %>% filter(!contig_name %in% plascope_out$contig_name) %>% mutate(prediction="no prediction",software="plascope")
```

RFPlasmid
```{r}
rfplasmid_out <- read.csv("../../rfplasmid/results/rfplasmid_predictions/prediction.csv")
names(rfplasmid_out) <- c("short_name","prediction","votes_chromosome","votes_plasmid","contig_name")
rfplasmid_out$prediction[rfplasmid_out$prediction=="c"]<- "chromosome"
rfplasmid_out$prediction[rfplasmid_out$prediction=="p"]<- "plasmid"
rfplasmid_out %<>% mutate(software="rfplasmid")
#no_prediction_rfplasmid <- all_contigs %>% filter(!contig_name %in% rfplasmid_out$contig_name) %>% mutate(prediction="no prediction",software="rfplasmid")
```

Merge the outputs, take only the three common columns
```{r}
all_output <- rbind(select(mlplasmids_out,c(contig_name,prediction,software)),platon_out,plascope_out,select(rfplasmid_out,c(contig_name,prediction,software)))
```

### Calculate results
Determine true positives, false positives, true negatives and false negatives.
```{r}
all_analysis<- full_join(all_output,selected_contig_info,by="contig_name")
true_positives <- all_analysis %>% filter(prediction=="plasmid" & classification=="plasmid") %>% mutate(result="TP")
true_negatives <- all_analysis %>% filter(prediction=="chromosome" & classification=="chromosome") %>% mutate(result="TN")
false_positives <- all_analysis %>% filter(prediction=="plasmid" & classification=="chromosome") %>% mutate(result="FP")
false_negatives <- all_analysis %>% filter(prediction=="chromosome" & classification=="plasmid") %>% mutate(result="FN")
unclassified <- all_analysis %>% filter(prediction=="unclassified" & !is.na(classification)) %>% mutate(result="unclassified")
```

Bind together in final result file.  
All contigs that don't have a classification (the discarded contigs) are a separate group called 'no category'.
A column with the contig length is added to the dataset.
```{r,warning=FALSE}
final_result <- rbind(true_positives,true_negatives,false_positives,false_negatives,unclassified)
#no_prediction <- all_analysis %>% filter(prediction=="no prediction" & !is.na(classification)) %>% mutate(result="no prediction")
no_category <- all_analysis %>% filter(is.na(classification)) %>% mutate(result="no category")
final_result %<>% rbind(no_category)
final_result %<>% separate(contig_name,into=c("1","2","3","4","contig_length",sep='_'),remove=FALSE) %>% select(!c("1","2","3","4","_"))
```

Calculate metrics
```{r,message=FALSE}
count_results <- final_result %>% group_by(software) %>% count(result)
count_results %<>% spread(result,n) %>% mutate(precision=TP/(TP+FP),recall=TP/(TP+FN),f1_score=2*(precision*recall)/(precision+recall))
kable(count_results %>% select(precision,recall,f1_score))
```
Calculate metrics according to nr of basepairs
```{r,message=FALSE}
length_result <- final_result %>% group_by(software,result) %>% summarise(total_bp = sum(as.numeric(contig_length)))
count_lengths <- spread(length_result,result,total_bp) %>% mutate(precision=TP/(TP+FP),recall=TP/(TP+FN),f1_score=2*(precision*recall)/(precision+recall))
kable(count_lengths %>% select(precision,recall,f1_score))
```
### Plot results

```{r,echo=FALSE}
level_order_results <- c("TP","TN","FP","FN","unclassified","no category")
ggplot(final_result %>% group_by(software) %>% count(result),aes(x=n, y= factor(result, level= rev(level_order_results)),fill=factor(result, level= level_order_results)))+
  geom_bar(stat = "identity")+
  facet_wrap(~software,labeller = labeller(software=c("mlplasmids"="Mlplasmids","platon"="Platon","plascope"="PlaScope","rfplasmid"="RFPlasmid")))+
  labs(title="Contig predictions for each tool",x = "Number of contigs", y = "Outcome")+
  guides(fill= FALSE)+
  scale_fill_manual(values=c("#47954D","#75C24B","#B94B33","#FA6C4D","#FACE1B","#868686","#595959"))+
  scale_y_discrete(labels=rev(c("True Plasmid","True Chromosome","False Plasmid","False Chromosome","Unclassified","No category")))
```

```{r,echo=FALSE}
ggplot(length_result,aes(x=total_bp,y= factor(result, level= rev(level_order_results)),fill=factor(result, level= level_order_results)))+
  geom_bar(stat ='identity')+
  facet_wrap(~software,labeller = labeller(software=c("mlplasmids"="Mlplasmids","platon"="Platon","plascope"="PlaScope","rfplasmid"="RFPlasmid")))+
  labs(title="Basepair predictions for each tool (zoomed in)",x = "Nr. of basepairs", y = "Outcome")+
  guides(fill= FALSE)+
  scale_fill_manual(values=c("#47954D","#75C24B","#B94B33","#FA6C4D","#FACE1B","#868686","#595959"))+
  coord_cartesian(xlim=c(0,1e7))+
  scale_y_discrete(labels=rev(c("True Plasmid","True Chromosome","False Plasmid","False Chromosome","Unclassified","No category")))
```
```{r,echo=FALSE,message=FALSE,fig.height=7}
ggplot(final_result,aes(x=log(as.numeric(contig_length),10),fill=factor(result, level= level_order_results)))+
  geom_histogram()+
  scale_fill_manual(labels=c("True Plasmid","True Chromosome","False Plasmid","False Chromosome","Unclassified","No category"),values=c("#47954D","#75C24B","#B94B33","#FA6C4D","#FACE1B","#868686","#595959"))+
  labs(title="Predictions according to contig length",x = "Contig length (log10 bp)", y = "Count",fill="Result")+
  facet_wrap(~software,labeller = labeller(software=c("mlplasmids"="Mlplasmids","platon"="Platon","plascope"="PlaScope","rfplasmid"="RFPlasmid")))
```

###Combining multiple softwares
Venn diagram

We make venn diagrams of incorrectly and correctly identified plasmids and chromosomes.
For PlaScope, we will categorise all unidentified contigs as 'incorrect'.
```{r}
false_negatives_venn <- rbind(false_negatives,unclassified %>% filter(classification=="chromosome"))
false_positives_venn <- rbind(false_positives,unclassified %>% filter(classification=="plasmid"))
```

```{r}
venn_TP <- list(Mlplasmids = true_positives %>% filter(software=='mlplasmids') %>% pull(contig_name),Platon =true_positives %>% filter(software=='platon') %>% pull(contig_name),PlaScope=true_positives %>% filter(software=='plascope') %>% pull(contig_name),RFPlasmid=true_positives %>% filter(software=='rfplasmid') %>% pull(contig_name))
VennDiagram <- venn.diagram(venn_TP,filename = NULL,fill=brewer.pal(4, "Set3"))
cowplot::plot_grid(VennDiagram)
```

```{r}
venn_TN <- list(Mlplasmids = true_negatives %>% filter(software=='mlplasmids') %>% pull(contig_name),Platon =true_negatives %>% filter(software=='platon') %>% pull(contig_name),PlaScope=true_negatives %>% filter(software=='plascope') %>% pull(contig_name),RFPlasmid=true_negatives %>% filter(software=='rfplasmid') %>% pull(contig_name))
VennDiagram <- venn.diagram(venn_TN,filename = NULL,fill=brewer.pal(4, "Set3"))
cowplot::plot_grid(VennDiagram)
```

```{r}
venn_FP <- list(Mlplasmids = false_positives_venn %>% filter(software=='mlplasmids') %>% pull(contig_name),Platon =false_positives_venn %>% filter(software=='platon') %>% pull(contig_name),PlaScope=false_positives_venn %>% filter(software=='plascope') %>% pull(contig_name),RFPlasmid=false_positives_venn %>% filter(software=='rfplasmid') %>% pull(contig_name))
VennDiagram <- venn.diagram(venn_FP,filename = NULL,fill=brewer.pal(4, "Set3"))
cowplot::plot_grid(VennDiagram)
```

```{r}
venn_FN <- list(Mlplasmids = false_negatives_venn %>% filter(software=='mlplasmids') %>% pull(contig_name),Platon =false_negatives_venn %>% filter(software=='platon') %>% pull(contig_name),PlaScope=false_negatives_venn %>% filter(software=='plascope') %>% pull(contig_name),RFPlasmid=false_negatives_venn %>% filter(software=='rfplasmid') %>% pull(contig_name))
VennDiagram <- venn.diagram(venn_FN,filename = NULL,fill=brewer.pal(4, "Set3"))
cowplot::plot_grid(VennDiagram)
```

```{r,fig.show='hide'}
venn_counts_TP <- as.tibble(as.list(lengths(attributes(venn(venn_TP))$intersections)))
venn_counts_TN <- as.tibble(as.list(lengths(attributes(venn(venn_TN))$intersections)))
venn_counts_FP <- as.tibble(as.list(lengths(attributes(venn(venn_FP))$intersections)))
venn_counts_FN <- as.tibble(as.list(lengths(attributes(venn(venn_FN))$intersections)))
venn_counts <- merge(merge(merge(venn_counts_TP,venn_counts_TN,all=TRUE),venn_counts_FN,all=TRUE),venn_counts_FP,all=TRUE)
venn_counts %<>% replace(is.na(.), 0)
rownames(venn_counts) <- c("TN","TP","FN","FP")
```

```{r}
for (software in c("Mlplasmids","Platon","PlaScope","RFPlasmid")){
  venn_counts$new_column <- rowSums(venn_counts[grepl(software,colnames(venn_counts))])
  names(venn_counts)[names(venn_counts) == "new_column"] <- paste("Total",software,sep = "_")
}
venn_scores <- venn_counts %>% select(Total_Mlplasmids,Total_Platon,Total_PlaScope,Total_RFPlasmid)
venn_scores <- as.data.frame(t(venn_scores))
rownames(venn_scores) <- str_replace(row.names(venn_scores),"Total_","")
venn_scores %<>% mutate(precision=TP/(TP+FP),recall=TP/(TP+FN),f1_score=2*(precision*recall)/(precision+recall))
```

```{r}
kable(venn_scores)
```

For calculating the combination scores, we convert all 'unclassified' contigs of PlaScope to chromosome.
```{r,fig.show='hide'}
true_negatives_venn2 <- rbind(true_negatives,unclassified %>% filter(classification=="chromosome"))
false_negatives_venn2 <- rbind(false_negatives,unclassified %>% filter(classification=="plasmid"))

venn_TN2 <- list(Mlplasmids = true_negatives_venn2 %>% filter(software=='mlplasmids') %>% pull(contig_name),Platon =true_negatives_venn2 %>% filter(software=='platon') %>% pull(contig_name),PlaScope=true_negatives_venn2 %>% filter(software=='plascope') %>% pull(contig_name),RFPlasmid=true_negatives_venn2 %>% filter(software=='rfplasmid') %>% pull(contig_name))
venn_FN2 <- list(Mlplasmids = false_negatives_venn2 %>% filter(software=='mlplasmids') %>% pull(contig_name),Platon =false_negatives_venn2 %>% filter(software=='platon') %>% pull(contig_name),PlaScope=false_negatives_venn2 %>% filter(software=='plascope') %>% pull(contig_name),RFPlasmid=false_negatives_venn2 %>% filter(software=='rfplasmid') %>% pull(contig_name))
venn_counts_TN2 <- as.tibble(as.list(lengths(attributes(venn(venn_TN2))$intersections)))
venn_counts_FN2 <- as.tibble(as.list(lengths(attributes(venn(venn_FN2))$intersections)))
venn_counts2 <- merge(merge(merge(venn_counts_TP,venn_counts_TN2,all=TRUE),venn_counts_FN2,all=TRUE),venn_counts_FP,all=TRUE)
venn_counts2 %<>% replace(is.na(.), 0)
rownames(venn_counts2) <- c("TP","TN","FN","FP")
```

```{r}
for (combination in c("Mlplasmids/Platon/PlaScope","Mlplasmids/Platon/RFPlasmid","Mlplasmids/PlaScope/RFPlasmid","Platon/PlaScope/RFPlasmid")){
  softwares <- unlist(str_split(combination,'/'))
  i<-1
  for (software in softwares){
    assign(paste("soft",i,sep=""),software)
    i<-i+1
  }
  pattern<-paste(":.*:|",soft1,":",soft2,"|",soft1,":",soft3,"|",soft2,":",soft3,sep = "")
  venn_counts2$new_column <- rowSums(venn_counts2[grepl(pattern,colnames(venn_counts2))])
  names(venn_counts2)[names(venn_counts2) == "new_column"] <- combination
}
```

```{r}
venn_scores2 <- venn_counts2 %>% select(`Mlplasmids/PlaScope/RFPlasmid`,`Mlplasmids/Platon/PlaScope`,`Mlplasmids/Platon/RFPlasmid`,`Platon/PlaScope/RFPlasmid`)
venn_scores2 <- as.data.frame(t(venn_scores2))
rownames(venn_scores2) <- str_replace(row.names(venn_scores2),"Total_","")
venn_scores2 %<>% mutate(precision=TP/(TP+FP),recall=TP/(TP+FN),f1_score=2*(precision*recall)/(precision+recall))
```

```{r}
kable(venn_scores2)
```
```{r}
VennDiagram <- venn.diagram(venn_FP,filename = NULL,fill=brewer.pal(4, "Set3"))
cowplot::plot_grid(VennDiagram)
```

Length distribution false positives and false negatives
```{r,fig.show='hide'}
venn_contigs_FN2 <- attributes(venn(venn_FN2))$intersections
venn_contigs_FP <- attributes(venn(venn_FP))$intersections
for (combination in c("Mlplasmids/Platon/PlaScope","Mlplasmids/Platon/RFPlasmid","Mlplasmids/PlaScope/RFPlasmid","Platon/PlaScope/RFPlasmid")){
  softwares <- unlist(str_split(combination,'/'))
  i<-1
  for (software in softwares){
    assign(paste("soft",i,sep=""),software)
    i<-i+1
  }
  pattern<-paste(":.*:|",soft1,":",soft2,"|",soft1,":",soft3,"|",soft2,":",soft3,sep = "")
  columns <- colnames(venn_counts[grepl(pattern,colnames(venn_counts))])
  file_FP <- as_tibble(data.frame())
  file_FN <- as_tibble(data.frame())
  for (column in columns){
    file_FP <- rbind(file_FP,as.tibble(venn_contigs_FP[[column]]))
    file_FN <- rbind(file_FN,as.tibble(venn_contigs_FN2[[column]]))
  }
  venn_combinations_contigs_FN <- c(venn_combinations_contigs_FN,new_element=list(file_FN))
  names(venn_combinations_contigs_FN)[names(venn_combinations_contigs_FN) == "new_element"] <- combination
  venn_combinations_contigs_FP <- c(venn_combinations_contigs_FP,new_element=list(file_FP))
  names(venn_combinations_contigs_FP)[names(venn_combinations_contigs_FP) == "new_element"] <- combination
}
```

```{r}

```

