---
title: "Binary classifier benchmarking study"
author: "Lisa"
date: "10/06/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,fig.width = 9,fig.align = "left")
```

```{r, include=FALSE}
require(readr)
require(magrittr)
require(dplyr)
require(ggplot2)
require(stringr)
require(tidyr)
require(knitr)
require(ggrepel)
require(VennDiagram)
require(RColorBrewer)
require(tibble)
require(venn)
```

```{r, include=FALSE}
theme_set(theme_bw())
```

### Introduction
This script is used to test the performance of four binary classifiers (Mlplasmids,Platon,Plascope and RFPlasmid) that were developed to differentiate chromosomal contigs from plasmidal contigs. We evaluate their performance specifically for E. coli ST131 strains, using a benchmarking dataset of 50 ST131 samples that have been sequenced by short-read as well as long-read technologies, and that have their complete genomes. We have previously assembled the short reads of all samples and used the resulting contigs as input for the four binary classifiers. These contigs have also been mapped to their reference genomes by QUAST so that we know whether they belong to the chromosome or the plasmid. Now we will assess for each contig whether the prediction made by the binary classifiers matches the actual classification.


### Import contig related data##
Import replicon data.  
This file contains the classifications (chromosome or plasmid) for all replicons in our dataset.
```{r}
replicon_data <- read.csv("../../../ST131_ncbi_download/results/replicon_data.csv", header = FALSE)
names(replicon_data)<-c('assembly_accession','replicon_name','replicon_length','classification')
```

Import all contig names.  
The full list of all contigs in our dataset.
```{r}
all_contigs <- read.csv("../../../ST131_ncbi_download/results/shortread_assemblies_bactofidia/all_contig_names.txt", header = FALSE)
names(all_contigs)="contig_name"
all_contigs %<>% mutate(contig_name=str_replace(contig_name,'>',''))
```

Import quast information.  
Quast has been used to align the contigs to one of the replicons in the reference genome. However, not all contigs could be fully aligned to one replicon. We will select only those contigs for which we are confident that they belong to a certain replicon.  

The quast output file we import here contains the lines in the all_alignments files for which best_group is true (this includes all strains).  
We do some preprocessing of the output file:  
* Assess whether contigs appear multiple times (are duplicated)  
* Extract contig length from contig name  
* Convert start, end and contig length columns to integer type instead of character  
* Calculate the alignment length by substracting S2 (start of contig) from E2 (end of contig). (A one is added to compensate for the starting base that is also substracted, while it should be included in the alignment length)  

```{r,message=FALSE,warning=FALSE}
quast_out <- read_tsv("../../../ST131_ncbi_download/results/bactofidia_all_true_alignments.tsv", col_names = c("S1","E1","S2","E2","replicon_name","contig_name","identity","ambiguous","best_group"))
quast_out %<>% mutate(duplicated = duplicated(contig_name) | duplicated(contig_name, fromLast = TRUE))
quast_out %<>% mutate(contig_length=as.numeric(sub(".*?length_(.*?)_.*", "\\1",contig_name)))
quast_out %<>% mutate_each_(funs(as.integer), c("S1","E1","S2","E2","contig_length")) 
quast_out %<>% mutate(alignment_length=abs(S2-E2)+1)
```
### Contig selection
Make groups based on type of contig.  
If a contig only appears in the output file once, this means it only aligns to one part of the reference, and it is correctly aligned.  
Ambiguously aligned contigs are called based on the ambiguous column in the output file.  
Contigs that have another issue (misassemblies such as relocations, inversions, translocations and local misassemblies, or fake misassemblies) appear multiple times and are not ambiguous.

```{r}
correct_contigs <- quast_out %>% filter(duplicated=="FALSE")
ambiguous_contigs <- quast_out %>% filter(ambiguous=="TRUE")
other_contigs <- quast_out %>% filter(duplicated=="TRUE" & is.na(ambiguous))
```

For each group we will perform a separate contig selection.  

For correctly aligned contigs, we simply calculate the percentage aligned by dividing the alignment length by the contig length.  
Only contigs that have an alignment of 90% or more are kept. 
```{r}
correct_contigs %<>% mutate(percentage_aligned=alignment_length/contig_length*100)
failed_contigs <- correct_contigs %>% filter(percentage_aligned < 90) %>% select(contig_name,replicon_name) %>% mutate(contig_type="failed_threshold")
correct_contigs %<>% filter(percentage_aligned >= 90) %>% select(contig_name,replicon_name) %>% mutate(contig_type="correctly_aligned")
```


Ambiguously aligned contigs are categorised according to the nr. of replicons they align to.  
Contigs that only map to one replicon and have an alignment of at least 90% are always kept.  
Contigs that map to multiple replicons are only kept if these replicons are all plasmids and if they have an alignment of at least 90%.
```{r}
ambiguous_contigs %<>% mutate(percentage_aligned=alignment_length/contig_length*100)
ambiguous_contigs %<>% group_by(contig_name) %>% mutate(multiple_replicons = n_distinct(replicon_name))
failed_contigs <- rbind(failed_contigs,ambiguous_contigs %>% filter(percentage_aligned < 90)  %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="failed_threshold"))
ambiguous_contigs_one <- ambiguous_contigs %>% filter(multiple_replicons==1 & percentage_aligned >= 90) %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="ambiguously_aligned_one_replicon")
ambiguous_contigs_multiple <- ambiguous_contigs %>% filter(multiple_replicons!=1 & percentage_aligned >= 90)
ambiguous_contigs_multiple %<>% left_join(replicon_data,by="replicon_name") %>% group_by(contig_name) %>% mutate(multiple_classifications = n_distinct(classification))
ambiguous_contigs_multiple_good <- ambiguous_contigs_multiple %>% filter(multiple_classifications==1) %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="ambiguously_aligned_only_plasmid")
ambiguous_contigs_multiple_bad <- ambiguous_contigs_multiple %>% filter(multiple_classifications!=1) %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="ambiguously_aligned_both")
```

(Supposedly) misassembled contigs have different parts of the contig aligning to different regions of the reference.  
For these contigs, the total alignment length is calculated by summing all alignment lengths of a contig.  
This 'actual' alignment length is used for calculation of the alignment percentage.  
Again, contigs are kept if they only only map to one replicon or map to multiple plasmids and if they have an alignment of at least 90%.  

```{r}
other_contigs %<>% group_by(contig_name) %>% mutate(total_alignment_length=sum(alignment_length))
other_contigs %<>% mutate(percentage_aligned=total_alignment_length/contig_length*100)
other_contigs %<>% group_by(contig_name) %>% mutate(multiple_replicons = n_distinct(replicon_name))
failed_contigs <- rbind(failed_contigs,other_contigs %>% filter(percentage_aligned < 90)  %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="failed_threshold"))
other_contigs_one <- other_contigs %>% filter(multiple_replicons==1 & percentage_aligned >= 90) %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="other_issue_one_replicon")
other_contigs_multiple <- other_contigs %>% filter(multiple_replicons!=1 & percentage_aligned >= 90)
other_contigs_multiple %<>% left_join(replicon_data,by="replicon_name") %>% group_by(contig_name) %>% mutate(multiple_classifications = n_distinct(classification))
other_contigs_multiple_good <- other_contigs_multiple %>% filter(multiple_classifications==1) %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="other_issue_only_plasmid")
other_contigs_multiple_bad <- other_contigs_multiple %>% filter(multiple_classifications!=1) %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="other_issue_both")
```

All accepted contigs are grouped together.
```{r}
selected_contigs <- rbind(correct_contigs,ambiguous_contigs_one,ambiguous_contigs_multiple_good,other_contigs_one,other_contigs_multiple_good)
```

Right now ambiguously aligned contigs and other contigs that are mapped to multiple replicons appear in the dataset twice.  
To prevent this, we remove contig names that are duplicated.

```{r}
selected_contigs %<>% mutate(duplicated=duplicated(contig_name))
selected_contigs %<>% filter(duplicated==FALSE) %>% select(!duplicated)
```

An overview of all contigs.  
All previously evaluated contigs were mapped at least partly to the reference. There are also contigs that couldn't be mapped at all, either because they're smaller than the cutoff length used (1000 bp) or due to misassemblies.
Unmapped contigs are those contig names that do not appear in the mapped dataset.

```{r}
mapped_contigs <- rbind(selected_contigs,ambiguous_contigs_multiple_bad,other_contigs_multiple_bad,failed_contigs)
mapped_contigs %<>% mutate(duplicated=duplicated(contig_name)) %>% filter(duplicated==FALSE) %>% select(!duplicated)
unmapped_contigs <- filter(all_contigs,!contig_name %in% mapped_contigs$contig_name) %>% mutate(contig_type="unmapped",replicon_name=NA)
contig_type_overview <- rbind(mapped_contigs,unmapped_contigs)
```

Remove replicons that occur in one of the tools' training sets or databases.
```{r}
replicons_to_remove <- read.csv("../results/replicons_to_remove", header = FALSE)
contig_type_overview %<>% filter(!replicon_name %in% replicons_to_remove$V1)
```

The relative frequency and length distribution of contig types. Selected contigs are coloured, discarded contigs in greyscale. Misassemblies also include fake misassemblies.  

```{r, echo=FALSE}
level_order_contigs <- c("correctly_aligned","ambiguously_aligned_one_replicon","ambiguously_aligned_only_plasmid","other_issue_one_replicon","other_issue_only_plasmid","unmapped","failed_threshold","ambiguously_aligned_both")
ggplot(contig_type_overview %>% count(contig_type),aes(x="",y=n,fill=factor(contig_type,level = rev(level_order_contigs))))+
  geom_bar(width = 1,stat = "identity")+
  coord_polar("y",start=0)+
  scale_fill_manual(labels=rev(c("Correctly aligned","Ambiguously aligned to one replicon","Ambiguously aligned to multiple plasmids","Misassembled and aligned to one replicon","Misassembled and aligned to multiple plasmids","Unaligned","Alignment less than 90% of contig size","Ambiguously aligned to both plasmid and chromosome")),values=rev(c("#ffa600","#ff6361","#bc5090","#58508d","#003f5c","#bcbcbc","#8b8b8c","#5c5d5f")))+
  #geom_label_repel(aes(label = n), size=3, position = position_stack(vjust = 0.5))+
  labs(title = "Relative frequency of contig types",x = "",y = "Count",fill="Contig type")+
  guides(fill=guide_legend(reverse = TRUE))

```
  
```{r, echo=FALSE,warning=FALSE,message=FALSE}
contig_type_overview %<>% mutate(contig_length=as.numeric(sub(".*?length_(.*?)_.*", "\\1",contig_name)))
ggplot(contig_type_overview,aes(x=log(contig_length,10),fill=factor(contig_type,level = level_order_contigs)))+
  geom_histogram()+
  scale_fill_manual(labels=c("Correctly aligned","Ambiguously aligned to one replicon","Ambiguously aligned to multiple plasmids","Misassembled and aligned to one replicon","Misassembled and aligned to multiple plasmids","Unaligned","Alignment less than 90% of contig size","Ambiguously aligned to both plasmid and chromosome"),values=c("#ffa600","#ff6361","#bc5090","#58508d","#003f5c","#bcbcbc","#8b8b8c","#5c5d5f"))+
  labs(title = "Length distribution of contig types",x="Contig length (log10 bp)",y = "Count",fill="Contig type")
```
  
45% of all contigs could be correctly mapped to a replicon.  
43% could not be aligned at all, most of them being smaller than 1000 bp.  
4% of contigs were ambiguously aligned, mostly to only one replicon.   
6% of contigs had some kind of (supposed) misassembly event going on, almost all of them within the same replicon.  
1% of contigs were discarded because the contig had an alignment of less than 90%.  
Ambiguously aligned contigs appear to be short, while 'misassembled' contigs are longer.  

Add classifications to the replicons of selected contigs.
```{r}
selected_contig_info <- full_join(selected_contigs,replicon_data,by="replicon_name")
```

### Import binary classifier output
Mlplasmids
```{r,message=FALSE}
mlplasmids_out <- read_tsv("../../mlplasmids/results/mlplasmids_all_results.tsv")
names(mlplasmids_out)<-c('assembly_accession','sra_accession','prob_chromosome','prob_plasmid','prediction','contig_name','contig_length')
mlplasmids_out$prediction %<>% tolower()
mlplasmids_out %<>% mutate(software="mlplasmids")
#no_prediction_mlplasmids <- all_contigs %>% filter(!contig_name %in% mlplasmids_out$contig_name) %>% mutate(prediction="no prediction",software="mlplasmids")
```

Platon
```{r}
platon_out <- read.csv("../../platon/results/platon_all_results.csv", header = FALSE)
names(platon_out) <- c("contig_name","prediction")
platon_out %<>% mutate(contig_name=str_replace(contig_name,'>',''))
platon_out %<>% mutate(software="platon")
#no_prediction_platon <- all_contigs %>% filter(!contig_name %in% platon_out$contig_name) %>% mutate(prediction="no prediction",software="platon")
```

Plascope
```{r}
plascope_out <- read.csv("../../plascope/results/plascope_all_results.csv", header = FALSE)
names(plascope_out) <- c("contig_name","prediction")
plascope_out %<>% mutate(contig_name=str_replace(contig_name,'>',''))
plascope_out %<>% mutate(software="plascope")
#no_prediction_plascope <- all_contigs %>% filter(!contig_name %in% plascope_out$contig_name) %>% mutate(prediction="no prediction",software="plascope")
```

RFPlasmid
```{r}
rfplasmid_out <- read.csv("../../rfplasmid/results/rfplasmid_predictions/prediction.csv")
names(rfplasmid_out) <- c("short_name","prediction","votes_chromosome","votes_plasmid","contig_name")
rfplasmid_out$prediction[rfplasmid_out$prediction=="c"]<- "chromosome"
rfplasmid_out$prediction[rfplasmid_out$prediction=="p"]<- "plasmid"
rfplasmid_out %<>% mutate(software="rfplasmid")
#no_prediction_rfplasmid <- all_contigs %>% filter(!contig_name %in% rfplasmid_out$contig_name) %>% mutate(prediction="no prediction",software="rfplasmid")
```

Merge the outputs, take only the three common columns
```{r}
all_output <- rbind(select(mlplasmids_out,c(contig_name,prediction,software)),platon_out,plascope_out,select(rfplasmid_out,c(contig_name,prediction,software)))
```

### Calculate results
Cross the output with the selected contigs.
Remove strains that occur in one of the tools' training sets or databases.
```{r}
all_analysis<- full_join(all_output,selected_contig_info,by="contig_name")
assemblies_to_remove <- read.csv("../results/assemblies_to_remove", header = FALSE)
all_analysis %<>% filter(!assembly_accession %in% assemblies_to_remove$V1)
```

Determine true positives, false positives, true negatives and false negatives.
```{r}
true_positives <- all_analysis %>% filter(prediction=="plasmid" & classification=="plasmid") %>% mutate(result="TP")
true_negatives <- all_analysis %>% filter(prediction=="chromosome" & classification=="chromosome") %>% mutate(result="TN")
false_positives <- all_analysis %>% filter(prediction=="plasmid" & classification=="chromosome") %>% mutate(result="FP")
false_negatives <- all_analysis %>% filter(prediction=="chromosome" & classification=="plasmid") %>% mutate(result="FN")
unclassified <- all_analysis %>% filter(prediction=="unclassified" & !is.na(classification)) %>% mutate(result="unclassified")
```

Bind together in final result file.  
All contigs that don't have a classification (the discarded contigs) are a separate group called 'no category'.
A column with the contig length is added to the dataset.
```{r,warning=FALSE}
final_result <- rbind(true_positives,true_negatives,false_positives,false_negatives,unclassified)
#no_prediction <- all_analysis %>% filter(prediction=="no prediction" & !is.na(classification)) %>% mutate(result="no prediction")
no_category <- all_analysis %>% filter(is.na(classification)) %>% mutate(result="no category")
final_result %<>% rbind(no_category)
final_result %<>% mutate(contig_length=as.numeric(sub(".*?length_(.*?)_.*", "\\1",contig_name)))
```

Calculate metrics
```{r,message=FALSE}
count_results <- final_result %>% group_by(software) %>% count(result)
count_results %<>% spread(result,n) %>% mutate(precision=TP/(TP+FP),recall=TP/(TP+FN),f1_score=2*(precision*recall)/(precision+recall))
kable(count_results %>% select(TP,TN,FP,FN,precision,recall,f1_score),caption = "Performance of binary classifiers (calculated per contig)")
```

```{r,echo=FALSE}
level_order_results <- c("TP","TN","FP","FN","unclassified","no category")
ggplot(final_result %>% group_by(software) %>% count(result),aes(x=n, y= factor(result, level= rev(level_order_results)),fill=factor(result, level= level_order_results)))+
  geom_bar(stat = "identity")+
  facet_wrap(~software,labeller = labeller(software=c("mlplasmids"="Mlplasmids","platon"="Platon","plascope"="PlaScope","rfplasmid"="RFPlasmid")))+
  labs(title="Contig predictions for each tool",x = "Number of contigs", y = "Outcome")+
  guides(fill= FALSE)+
  scale_fill_manual(values=c("#47954D","#75C24B","#B94B33","#FA6C4D","#FACE1B","#5c5d5f"))+
  scale_y_discrete(labels=rev(c("TP","TN","FP","FN","Unclassified","No category")))
```

Instead of calculating the metrics for each contig, we can also assess the total number of basepairs that a software identifies as correct/incorrect.
Because longer contigs are easier to categorise, this leads to more favourable results.

```{r,message=FALSE}
length_result <- final_result %>% group_by(software,result) %>% summarise(total_bp = sum(contig_length))
count_lengths <- spread(length_result,result,total_bp) %>% mutate(precision=TP/(TP+FP),recall=TP/(TP+FN),f1_score=2*(precision*recall)/(precision+recall))
kable(count_lengths %>% select(TP,TN,FP,FN,precision,recall,f1_score),caption = "Performance of binary classifiers (calculated per basepair)")
```

```{r,echo=FALSE}
ggplot(length_result,aes(x=total_bp,y= factor(result, level= rev(level_order_results)),fill=factor(result, level= level_order_results)))+
  geom_bar(stat ='identity')+
  facet_wrap(~software,labeller = labeller(software=c("mlplasmids"="Mlplasmids","platon"="Platon","plascope"="PlaScope","rfplasmid"="RFPlasmid")))+
  labs(title="Basepair predictions for each tool (zoomed in)",x = "Nr. of basepairs", y = "Outcome")+
  guides(fill= FALSE)+
  scale_fill_manual(values=c("#47954D","#75C24B","#B94B33","#FA6C4D","#FACE1B","#868686","#595959"))+
  coord_cartesian(xlim=c(0,1e7))+
  scale_y_discrete(labels=rev(c("TP","TN","FP","FN","Unclassified","No category")))
```
```{r,echo=FALSE,message=FALSE,fig.height=7}
ggplot(final_result,aes(x=log(contig_length,10),fill=factor(result, level= level_order_results)))+
  geom_histogram()+
  scale_fill_manual(labels=c("TP","TN","FP","FN","Unclassified","No category"),values=c("#47954D","#75C24B","#B94B33","#FA6C4D","#FACE1B","#868686","#595959"))+
  labs(title="Predictions according to contig length",x = "Contig length (log10 bp)", y = "Count",fill="Result")+
  facet_wrap(~software,labeller = labeller(software=c("mlplasmids"="Mlplasmids","platon"="Platon","plascope"="PlaScope","rfplasmid"="RFPlasmid")))
```
  
### Conclusions  
Out of the four softwares, PlaScope calls the least false chromosomes and false plasmids, which results in a high F1-score of 94.9% (97,0% when counting per basepair). Although this tool scores very favourably for the contigs it assigns to a conclusive category (either plasmid or chromosome), it also assigns a part of the contigs to the 'unclassified' category. Because the other tools categorise contigs in a strictly binary matter, comparison to PlaScope based on recall, precision and F1-score is not fair. To compensate for this effect, we can consider all unclassified contigs as incorrect, i.e. we artificially assign the category 'chromosome' to the plasmidal contigs, and 'plasmid' to the chromosomal contigs.
```{r}
final_result_adj <- final_result %>% mutate(result=ifelse(prediction=="unclassified" & classification=="plasmid","FP",result)) %>% mutate(result=ifelse(prediction=="unclassified" & classification=="chromosome","FN",result)) %>% mutate(result=ifelse(is.na(result),"no category",result))
```

When we now calculate the metrics, they have gone down for PlaScope. Interestingly, the difference is much smaller when we calculate the metrics per basepair instead of per contig. This makes sense, because the unclassified contigs are relatively small in size.
```{r,message=FALSE}
count_results_adj <- final_result_adj %>% group_by(software) %>% count(result)
count_results_adj %<>% spread(result,n) %>% mutate(precision=TP/(TP+FP),recall=TP/(TP+FN),f1_score=2*(precision*recall)/(precision+recall))
kable(count_results_adj %>% select(TP,TN,FP,FN,precision,recall,f1_score),caption = "Performance of binary classifiers (calculated per contig, adjusted for unclassified contigs)")
```

```{r,message=FALSE}
length_result_adj <- final_result_adj %>% group_by(software,result) %>% summarise(total_bp = sum(contig_length))
count_lengths_adj <- spread(length_result_adj,result,total_bp) %>% mutate(precision=TP/(TP+FP),recall=TP/(TP+FN),f1_score=2*(precision*recall)/(precision+recall))
kable(count_lengths_adj %>% select(TP,TN,FP,FN,precision,recall,f1_score),caption = "Performance of binary classifiers (calculated per basepair, adjusted for unclassified contigs)")
```

RFPlasmid has the lowest F1-score, when calculated per contig (80.8%) as well as per basepair (86.7%), mainly due to a low precision (= many false positives). However, RFPlasmid does score an exceptionally high recall for large contigs (95.0%), which is the highest recall of all tools when considered per basepair. Platon accomplishes the highest recall when calculated per contig (85.9%). PlaScope performs best in terms of precision (contig: 89.5%, bp: 94.0%), resulting in a top F1-score (contig: 85.5%, bp: 94.4%). However, the lack of conclusive results for some contigs poses a major drawback in using PlaScope as a binary classifier. Based on these results, Platon would be most suitable to use as a classifier.


### Combining multiple softwares
We are also interested in whether combining the outputs of multiple binary classifiers into an ensemble classifier improves our results.
We can explore which contigs are differentially predicted by different softwares using Venn diagrams.  
For PlaScope, we will again categorise all unidentified contigs as 'incorrect'.
```{r}
false_negatives_venn <- rbind(false_negatives,unclassified %>% filter(classification=="chromosome"))
false_positives_venn <- rbind(false_positives,unclassified %>% filter(classification=="plasmid"))
```

Build Venn diagrams
```{r}
#Make a list of all true positives per software
venn_TP <- list(Mlplasmids = true_positives %>% filter(software=='mlplasmids') %>% pull(contig_name),Platon =true_positives %>% filter(software=='platon') %>% pull(contig_name),PlaScope=true_positives %>% filter(software=='plascope') %>% pull(contig_name),RFPlasmid=true_positives %>% filter(software=='rfplasmid') %>% pull(contig_name))
#Convert list to venn diagram
VennTP <- venn.diagram(venn_TP,filename = NULL,fill=brewer.pal(4, "Set3"))
```

```{r}
venn_TN <- list(Mlplasmids = true_negatives %>% filter(software=='mlplasmids') %>% pull(contig_name),Platon =true_negatives %>% filter(software=='platon') %>% pull(contig_name),PlaScope=true_negatives %>% filter(software=='plascope') %>% pull(contig_name),RFPlasmid=true_negatives %>% filter(software=='rfplasmid') %>% pull(contig_name))
VennTN<- venn.diagram(venn_TN,filename = NULL,fill=brewer.pal(4, "Set3"))
```

```{r}
venn_FP <- list(Mlplasmids = false_positives_venn %>% filter(software=='mlplasmids') %>% pull(contig_name),Platon =false_positives_venn %>% filter(software=='platon') %>% pull(contig_name),PlaScope=false_positives_venn %>% filter(software=='plascope') %>% pull(contig_name),RFPlasmid=false_positives_venn %>% filter(software=='rfplasmid') %>% pull(contig_name))
VennFP<- venn.diagram(venn_FP,filename = NULL,fill=brewer.pal(4, "Set3"))
```

```{r}
venn_FN <- list(Mlplasmids = false_negatives_venn %>% filter(software=='mlplasmids') %>% pull(contig_name),Platon =false_negatives_venn %>% filter(software=='platon') %>% pull(contig_name),PlaScope=false_negatives_venn %>% filter(software=='plascope') %>% pull(contig_name),RFPlasmid=false_negatives_venn %>% filter(software=='rfplasmid') %>% pull(contig_name))
VennFN<- venn.diagram(venn_FN,filename = NULL,fill=brewer.pal(4, "Set3"))
```

```{r,echo=FALSE}
cowplot::plot_grid(VennTP,VennTN,labels = c("True Positives","True Negatives"),label_x = 0.1)
cowplot::plot_grid(VennFP,VennFN,labels = c("False Positives","False Negatives"),label_x = 0.1)
```
These diagrams show that false positives and false negatives are often misclassified by only one of the softwares, while the other softwares classify them correctly. Besides, a significant portion of true positives and true negatives is correctly identified by two or three, but not all of the tools.

We now explore what happens when we combine three of the softwares, and assume the classification that the majority of softwares call.  
In order to include the 'unclassified' contigs from PlaScope, we always categorise them as 'chromosome'.
```{r}
true_negatives_venn2 <- rbind(true_negatives,unclassified %>% filter(classification=="chromosome"))
false_negatives_venn2 <- rbind(false_negatives,unclassified %>% filter(classification=="plasmid"))
```

Because we changed the classification of unidentified contigs, we have to make new lists for true negatives, false negatives and false positives.
```{r}
venn_TN2 <- list(Mlplasmids = true_negatives_venn2 %>% filter(software=='mlplasmids') %>% pull(contig_name),Platon =true_negatives_venn2 %>% filter(software=='platon') %>% pull(contig_name),PlaScope=true_negatives_venn2 %>% filter(software=='plascope') %>% pull(contig_name),RFPlasmid=true_negatives_venn2 %>% filter(software=='rfplasmid') %>% pull(contig_name))
venn_FN2 <- list(Mlplasmids = false_negatives_venn2 %>% filter(software=='mlplasmids') %>% pull(contig_name),Platon =false_negatives_venn2 %>% filter(software=='platon') %>% pull(contig_name),PlaScope=false_negatives_venn2 %>% filter(software=='plascope') %>% pull(contig_name),RFPlasmid=false_negatives_venn2 %>% filter(software=='rfplasmid') %>% pull(contig_name))
venn_FP2 <- list(Mlplasmids = false_positives %>% filter(software=='mlplasmids') %>% pull(contig_name),Platon =false_positives %>% filter(software=='platon') %>% pull(contig_name),PlaScope=false_positives %>% filter(software=='plascope') %>% pull(contig_name),RFPlasmid=false_positives %>% filter(software=='rfplasmid') %>% pull(contig_name))
```

Count the number of contigs at the intersections of the resulting venn diagrams (not drawn). For example, for all true positive contigs we count which tool or combination of tools categorised them as true positive. We do this for all results, and merge the files.
```{r,fig.show='hide'}
venn_counts_TP <- as_tibble(as.list(lengths(attributes(venn(venn_TP))$intersections)))
venn_counts_FP2 <- as_tibble(as.list(lengths(attributes(venn(venn_FP2))$intersections)))
venn_counts_TN2 <- as_tibble(as.list(lengths(attributes(venn(venn_TN2))$intersections)))
venn_counts_FN2 <- as_tibble(as.list(lengths(attributes(venn(venn_FN2))$intersections)))
venn_counts2 <- merge(merge(merge(venn_counts_TP,venn_counts_TN2,all=TRUE),venn_counts_FN2,all=TRUE),venn_counts_FP2,all=TRUE)
venn_counts2 %<>% replace(is.na(.), 0)
rownames(venn_counts2) <- c("FN","FP","TP","TN")
venn_counts2 <- venn_counts2[c("TP","TN","FP","FN"),]
```

We calculate the number of true positive, true negative, false positive and false negative contigs for each of the four combinations of softwares. Contigs are included if they are classified by at least two out of three softwares. This means that contigs predicted by three of four softwares are always included.
```{r}
for (combination in c("Mlplasmids/Platon/PlaScope","Mlplasmids/Platon/RFPlasmid","Mlplasmids/PlaScope/RFPlasmid","Platon/PlaScope/RFPlasmid")){
  #Split the input names into variables soft1/soft2/soft3
  softwares <- unlist(str_split(combination,'/'))
  i<-1
  for (software in softwares){
    assign(paste("soft",i,sep=""),software)
    i<-i+1
  }
  #For each column in venn_counts2 it is evaluated whether it is included in the final result.
  #This is the case if it contains three or four softwares in total, or two of the input softwares (soft1 + soft2, soft1 + soft3 or soft2 + soft3)
  pattern<-paste(":.*:|",soft1,":",soft2,"|",soft1,":",soft3,"|",soft2,":",soft3,sep = "")
  #The row sum of these columns is added as a new column named after the software combination
  venn_counts2$new_column <- rowSums(venn_counts2[grepl(pattern,colnames(venn_counts2))])
  names(venn_counts2)[names(venn_counts2) == "new_column"] <- combination
}
```

Calculate precision, recall and F1-score for the ensemble combinations.
```{r}
venn_scores2 <- venn_counts2 %>% select(`Mlplasmids/PlaScope/RFPlasmid`,`Mlplasmids/Platon/PlaScope`,`Mlplasmids/Platon/RFPlasmid`,`Platon/PlaScope/RFPlasmid`)
venn_scores2 <- as.data.frame(t(venn_scores2))
rownames(venn_scores2) <- str_replace(row.names(venn_scores2),"Total_","")
venn_scores2 %<>% mutate(precision=TP/(TP+FP),recall=TP/(TP+FN),f1_score=2*(precision*recall)/(precision+recall))
```

```{r,echo=FALSE}
kable(venn_scores2)
```
With regard to contigs, the ensemble classifiers outperform all the individual classifiers (top F1-score 85.5%). The combination Mlplasmids/Platon/PlaScope performs best with a recall of 96.8%, precision of 87.9% and F1-score of 92.1%. This combination scores the highest precision as well as the highest recall.

Furthermore, we can take a look at the length of the false positive and false negative contigs that are called by the ensemble classifiers. We want to avoid large contigs being misclassified.

Get the contig names of the false positives and false negatives for each ensemble classifier
```{r,fig.show='hide'}
#Get the contig names of false negatives and false postives grouped by software combination
venn_contigs_FN2 <- attributes(venn(venn_FN2))$intersections
venn_contigs_FP2 <- attributes(venn(venn_FP2))$intersections
incorrect_contigs_ensembles <- as_tibble(data.frame())
for (combination in c("Mlplasmids/Platon/PlaScope","Mlplasmids/Platon/RFPlasmid","Mlplasmids/PlaScope/RFPlasmid","Platon/PlaScope/RFPlasmid")){
  #Split the input names into variables soft1/soft2/soft3
  softwares <- unlist(str_split(combination,'/'))
  i<-1
  for (software in softwares){
    assign(paste("soft",i,sep=""),software)
    i<-i+1
  }
  #Apply same pattern as before for column selection
  pattern<-paste(":.*:|",soft1,":",soft2,"|",soft1,":",soft3,"|",soft2,":",soft3,sep = "")
  columns <- colnames(venn_counts2[grepl(pattern,colnames(venn_counts2))])
  file_FP <- as_tibble(data.frame())
  file_FN <- as_tibble(data.frame())
  #Rbind all contigs in those columns to intermediate files file_FP and file_FN
  for (column in columns){
    file_FP <- rbind(file_FP,as_tibble(venn_contigs_FP2[[column]]))
    file_FN <- rbind(file_FN,as_tibble(venn_contigs_FN2[[column]]))
  }
  #Add result and combination names
  file_FN %<>% mutate(result="FN",combination=combination)
  file_FP %<>% mutate(result="FP",combination=combination)
  #Append output file
  incorrect_contigs_ensembles <- rbind(incorrect_contigs_ensembles,file_FN,file_FP)
}
```

Calculate contig length
```{r}
incorrect_contigs_ensembles %<>% rename(contig_name=value) %>% mutate(contig_length=as.numeric(sub(".*?length_(.*?)_.*", "\\1",contig_name)))
```

```{r,message=FALSE}
ggplot(incorrect_contigs_ensembles,aes(x=log(contig_length,10),fill=result))+
  geom_histogram()+
  facet_wrap(~combination)+
  scale_fill_manual(values=c("#B94B33","#FA6C4D"))
```
Most miscategorised contigs are in the 1000 to 5000 (≈ 10e3.7) bp range. Mlplasmids/Platon/PlaScope misidentifies very few large contigs (>5000 bp), mostly are all false positives. 
