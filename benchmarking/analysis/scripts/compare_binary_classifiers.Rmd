---
title: "Binary classifier benchmarking study"
author: "Lisa"
date: "10/06/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,fig.width = 9,fig.align = "left")
```

```{r, include=FALSE}
packages <- c("readr","magrittr","dplyr","ggplot2","stringr","tidyr","knitr","ggrepel","VennDiagram","RColorBrewer","tibble","venn","flextable","patchwork","lubridate","UpSetR")
for (package in packages){
  if (!require(package, character.only = TRUE)) install.packages(package)
  require(package, character.only = TRUE)
}
```

```{r, include=FALSE}
theme_set(theme_bw())
```

### Introduction
This script is used to test the performance of four binary classifiers (Mlplasmids,Platon,Plascope and RFPlasmid) that were developed to differentiate chromosomal contigs from plasmidal contigs. We have previously assembled the short reads of all samples and used the resulting contigs as input for the four binary classifiers. These contigs have also been mapped to their reference genomes by QUAST so that we know whether they belong to the chromosome or the plasmid. Now we will assess for each contig whether the prediction made by the binary classifiers matches the actual classification.


### Import contig related data
Import replicon data.  
This file contains the classifications (chromosome or plasmid) for all replicons in our dataset.
```{r}
replicon_data <- read.csv("../../../Ecoli_ncbi_download/results/replicon_data.csv", header = FALSE)
names(replicon_data)<-c('assembly_accession','replicon_name','replicon_length','classification')
```

Import all contig names.
The full list of all contigs in our dataset.
```{r}
all_contigs <- read.csv("../../../Ecoli_ncbi_download/results/shortread_assemblies_bactofidia/all_contig_names.txt", header = FALSE)
names(all_contigs)="contig_name"
all_contigs %<>% mutate(contig_name=str_replace(contig_name,'>','')) %<>% mutate(contig_name=str_replace_all(contig_name,'-','_'))
```


Import quast information.  
Quast has been used to align the contigs to one of the replicons in the reference genome. However, not all contigs could be fully aligned to one replicon. We will select only those contigs for which we are confident that they belong to a certain replicon.  

The quast output file we import here contains the lines in the all_alignments files for which best_group is true (this includes all strains).  
We do some preprocessing of the output file:  
* Assess whether contigs appear multiple times (are duplicated)  
* Extract contig length from contig name  
* Convert start, end and contig length columns to integer type instead of character  
* Calculate the alignment length by substracting S2 (start of contig) from E2 (end of contig). (A one is added to compensate for the starting base that is also substracted, while it should be included in the alignment length)  

```{r,message=FALSE,warning=FALSE}
quast_out <- read_tsv("../../../Ecoli_ncbi_download/results/bactofidia_all_true_alignments.tsv", col_names = c("S1","E1","S2","E2","replicon_name","contig_name","identity","ambiguous","best_group"))
quast_out %<>% mutate(duplicated = duplicated(contig_name) | duplicated(contig_name, fromLast = TRUE))
quast_out %<>% mutate(contig_length=as.numeric(sub(".*?length_(.*?)_.*", "\\1",contig_name)))
quast_out %<>% mutate_each_(funs(as.integer), c("S1","E1","S2","E2","contig_length")) 
quast_out %<>% mutate(alignment_length=abs(S2-E2)+1)
```

### Contig selection
Make groups based on type of contig.  
If a contig only appears in the output file once, this means it only aligns to one part of the reference, and it is correctly aligned.  
Ambiguously aligned contigs are called based on the ambiguous column in the output file.  
Contigs that have another issue (misassemblies such as relocations, inversions, translocations and local misassemblies, or fake misassemblies) appear multiple times and are not ambiguous.

```{r}
correct_contigs <- quast_out %>% filter(duplicated=="FALSE")
ambiguous_contigs <- quast_out %>% filter(ambiguous=="TRUE")
other_contigs <- quast_out %>% filter(duplicated=="TRUE" & is.na(ambiguous))
```

For each group we will perform a separate contig selection.  

For correctly aligned contigs, we simply calculate the percentage aligned by dividing the alignment length by the contig length.  
Only contigs that have an alignment of 90% or more are kept. 
```{r}
correct_contigs %<>% mutate(percentage_aligned=alignment_length/contig_length*100)
failed_contigs <- correct_contigs %>% filter(percentage_aligned < 90) %>% select(contig_name,replicon_name) %>% mutate(contig_type="failed_threshold")
correct_contigs %<>% filter(percentage_aligned >= 90) %>% select(contig_name,replicon_name) %>% mutate(contig_type="correctly_aligned")
```


Ambiguously aligned contigs are categorised according to the nr. of replicons they align to.  
Contigs that only map to one replicon and have an alignment of at least 90% are always kept.  
Contigs that map to multiple replicons are only kept if these replicons are all plasmids and if they have an alignment of at least 90%.
```{r}
ambiguous_contigs %<>% mutate(percentage_aligned=alignment_length/contig_length*100)
ambiguous_contigs %<>% group_by(contig_name) %>% mutate(multiple_replicons = n_distinct(replicon_name))
failed_contigs <- rbind(failed_contigs,ambiguous_contigs %>% filter(percentage_aligned < 90)  %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="failed_threshold"))
ambiguous_contigs_one <- ambiguous_contigs %>% filter(multiple_replicons==1 & percentage_aligned >= 90) %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="ambiguously_aligned_one_replicon")
ambiguous_contigs_multiple <- ambiguous_contigs %>% filter(multiple_replicons!=1 & percentage_aligned >= 90)
ambiguous_contigs_multiple %<>% left_join(replicon_data,by="replicon_name") %>% group_by(contig_name) %>% mutate(multiple_classifications = n_distinct(classification))
ambiguous_contigs_multiple_good <- ambiguous_contigs_multiple %>% filter(multiple_classifications==1) %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="ambiguously_aligned_only_plasmid")
ambiguous_contigs_multiple_bad <- ambiguous_contigs_multiple %>% filter(multiple_classifications!=1) %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="ambiguously_aligned_both")
```

(Supposedly) misassembled contigs have different parts of the contig aligning to different regions of the reference.  
For these contigs, the total alignment length is calculated by summing all alignment lengths of a contig.  
This 'actual' alignment length is used for calculation of the alignment percentage.  
Again, contigs are kept if they only only map to one replicon or map to multiple plasmids and if they have an alignment of at least 90%.  

```{r}
other_contigs %<>% group_by(contig_name) %>% mutate(total_alignment_length=sum(alignment_length))
other_contigs %<>% mutate(percentage_aligned=total_alignment_length/contig_length*100)
other_contigs %<>% group_by(contig_name) %>% mutate(multiple_replicons = n_distinct(replicon_name))
failed_contigs <- rbind(failed_contigs,other_contigs %>% filter(percentage_aligned < 90)  %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="failed_threshold"))
other_contigs_one <- other_contigs %>% filter(multiple_replicons==1 & percentage_aligned >= 90) %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="other_issue_one_replicon")
other_contigs_multiple <- other_contigs %>% filter(multiple_replicons!=1 & percentage_aligned >= 90)
other_contigs_multiple %<>% left_join(replicon_data,by="replicon_name") %>% group_by(contig_name) %>% mutate(multiple_classifications = n_distinct(classification))
other_contigs_multiple_good <- other_contigs_multiple %>% filter(multiple_classifications==1) %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="other_issue_only_plasmid")
other_contigs_multiple_bad <- other_contigs_multiple %>% filter(multiple_classifications!=1) %>% select(contig_name,replicon_name) %>% unique() %>% mutate(contig_type="other_issue_both")
```

All accepted contigs are grouped together.
```{r}
selected_contigs <- rbind(correct_contigs,ambiguous_contigs_one,ambiguous_contigs_multiple_good,other_contigs_one,other_contigs_multiple_good)
```

Right now ambiguously aligned contigs and other contigs that are mapped to multiple replicons appear in the dataset twice.  
To prevent this, we remove contig names that are duplicated.

```{r}
selected_contigs %<>% mutate(duplicated=duplicated(contig_name))
selected_contigs %<>% filter(duplicated==FALSE) %>% select(!duplicated)
```

An overview of all contigs.  
All previously evaluated contigs were mapped at least partly to the reference. There are also contigs that couldn't be mapped at all, either because they're smaller than the cutoff length used (1000 bp) or due to misassemblies.
Unmapped contigs are those contig names that do not appear in the mapped dataset.

```{r}
mapped_contigs <- rbind(selected_contigs,ambiguous_contigs_multiple_bad,other_contigs_multiple_bad,failed_contigs)
mapped_contigs %<>% mutate(duplicated=duplicated(contig_name)) %>% filter(duplicated==FALSE) %>% select(!duplicated)
unmapped_contigs <- filter(all_contigs,!contig_name %in% mapped_contigs$contig_name) %>% mutate(contig_type="unmapped",replicon_name=NA)
contig_type_overview <- rbind(mapped_contigs,unmapped_contigs)
```

The relative frequency and length distribution of contig types. Selected contigs are coloured, discarded contigs in greyscale. Misassemblies also include fake misassemblies.  

```{r, echo=FALSE}
level_order_contigs <- c("correctly_aligned","ambiguously_aligned_one_replicon","ambiguously_aligned_only_plasmid","other_issue_one_replicon","other_issue_only_plasmid","unmapped","failed_threshold","ambiguously_aligned_both","other_issue_both")
ggplot(contig_type_overview %>% count(contig_type),aes(x="",y=n,fill=factor(contig_type,level = rev(level_order_contigs))))+
  geom_bar(width = 1,stat = "identity")+
  coord_polar("y",start=0)+
  scale_fill_manual(labels=rev(c("Correctly aligned","Ambiguously aligned to one replicon","Ambiguously aligned to multiple plasmids","Misassembled and aligned to one replicon","Misassembled and aligned to multiple plasmids","Unaligned","Alignment less than 90% of contig size","Ambiguously aligned to both plasmid and chromosome","Misassembled and aligned to both plasmid and chromosome")),values=rev(c("#ffa600","#ff6361","#bc5090","#58508d","#003f5c","#bcbcbc","#8b8b8c","#5c5d5f","#393939")))+
  #geom_label_repel(aes(label = n/sum(n)), size=3, position = position_stack(vjust = 0.5))+
  labs(title = "Relative frequency of contig types",x = "",y = "Count",fill="Contig type")+
  guides(fill=guide_legend(reverse = TRUE))

```
  
```{r}
ggsave('../results/figures/contigtypes.svg')
```

```{r, echo=FALSE,warning=FALSE,message=FALSE}
contig_type_overview %<>% mutate(contig_length=as.numeric(sub(".*?length_(.*?)_.*", "\\1",contig_name)))
ggplot(contig_type_overview,aes(x=log(contig_length,10),fill=factor(contig_type,level = level_order_contigs)))+
  geom_histogram(binwidth = 0.2, boundary=0)+
  scale_fill_manual(labels=c("Correctly aligned","Ambiguously aligned to one replicon","Ambiguously aligned to multiple plasmids","Misassembled and aligned to one replicon","Misassembled and aligned to multiple plasmids","Unaligned","Alignment less than 90% of contig size","Ambiguously aligned to both plasmid and chromosome","Misassembled and aligned to both plasmid and chromosome"),values=c("#ffa600","#ff6361","#bc5090","#58508d","#003f5c","#bcbcbc","#8b8b8c","#5c5d5f","#393939"))+
  labs(title = "Overview of contigs in the dataset",x="Contig length (log10 bp)",y = "Count",fill="Alignment type")
```
```{r}
ggsave('../results/figures/contiglengths.svg',width = 10,height = 5)
```  

Add classifications to the replicons of selected contigs.
```{r}
selected_contig_info <- full_join(selected_contigs,replicon_data,by="replicon_name")
```

### Import binary classifier output

```{r}
all_output <- read.csv("../../binary_classifiers/results/output_Ecoli_bac.csv", header = FALSE)
names(all_output) <- c("contig_name","prediction","software")
all_output %<>% mutate(contig_name=str_replace_all(contig_name,'-','_'))
```

### Calculate results
Cross the output with the selected contigs.
```{r}
all_analysis<- full_join(all_output,selected_contig_info,by="contig_name")
```

Determine true positives, false positives, true negatives and false negatives.
For PlaScope, we decided to treat 'unclassified' contigs as negatives (chromosome).
```{r}
true_positives <- all_analysis %>% filter(prediction=="plasmid" & classification=="plasmid") %>% mutate(result="TP")
true_negatives <- all_analysis %>% filter((prediction=="chromosome" | prediction=="unclassified") & classification=="chromosome") %>% mutate(result="TN")
false_positives <- all_analysis %>% filter(prediction=="plasmid" & classification=="chromosome") %>% mutate(result="FP")
false_negatives <- all_analysis %>% filter((prediction=="chromosome" | prediction=="unclassified")& classification=="plasmid") %>% mutate(result="FN")
```

Bind together in final result file.  
All contigs that don't have a classification (the discarded contigs) are a separate group called 'no category'.
A column with the contig length is added to the dataset.
```{r,warning=FALSE}
final_result <- rbind(true_positives,true_negatives,false_positives,false_negatives)
#no_prediction <- all_analysis %>% filter(prediction=="no prediction" & !is.na(classification)) %>% mutate(result="no prediction")
no_category <- all_analysis %>% filter(is.na(classification)) %>% mutate(result="no category")
final_result %<>% rbind(no_category)
final_result %<>% mutate(contig_length=as.numeric(sub(".*?length_(.*?)_.*", "\\1",contig_name)))
```

Calculate metrics
```{r,message=FALSE}
count_results <- final_result %>% group_by(software) %>% count(result)
count_results %<>% spread(result,n) %>% mutate(precision=TP/(TP+FP),recall=TP/(TP+FN),f1_score=2*(precision*recall)/(precision+recall))
count_results %>% select(TP,TN,FP,FN,precision,recall,f1_score) %>% flextable()
      #caption = "Performance of binary classifiers (calculated per contig)")
```

Show metrics in plot
```{r}
metrics_levels <- c('recall','precision','f1_score')
ggplot(count_results %>% select(software,precision,recall,f1_score) %>% pivot_longer(precision:f1_score, names_to = "metric", values_to = "value"),aes(x=software,y=value))+
  geom_point(size=3,aes(colour=factor(metric,level = metrics_levels)))+
  labs(title="Performance of binary classifiers",x="Software",y="Score",colour="Metric")+
  scale_colour_manual(labels=c("Recall","Precision","F1-Score"),values=c("#4c7af2","#f2924c","#f24c76"))+
  scale_x_discrete(labels=c("Mlplasmids","PlaScope","Platon","RFPlasmid"))+
  theme(plot.title = element_text(size = 12))
```

Plot per genome. Here we only select genomes that actually contain plasmids, otherwise precision and recall can't be established.
```{r}
count_results_per_genome <- final_result %>% group_by(software,assembly_accession) %>% count(result)
count_results_per_genome %<>% spread(result,n) %>% mutate_all(~replace(., is.na(.), 0)) %>% filter(TP+FN>0) %>% mutate(precision=TP/(TP+FP),recall=TP/(TP+FN),f1_score=2*(precision*recall)/(precision+recall))
```
```{r}
ggplot(count_results_per_genome,aes(x=software,y=f1_score))+
  geom_boxplot(outlier.shape = NA) +geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.5)
```


Instead of calculating the metrics for each contig, we can also assess the total number of basepairs that a software identifies as correct/incorrect.
Because longer contigs are easier to categorise, this leads to more favourable results.

```{r,message=FALSE}
length_result <- final_result %>% group_by(software,result) %>% summarise(total_bp = sum(contig_length))
count_lengths <- spread(length_result,result,total_bp) %>% mutate(precision=TP/(TP+FP),recall=TP/(TP+FN),f1_score=2*(precision*recall)/(precision+recall))
count_lengths %>% select(TP,TN,FP,FN,precision,recall,f1_score) %>% flextable() #caption = "Performance of binary classifiers (calculated per basepair)")
```


```{r,echo=FALSE,message=FALSE,fig.height=7}
final_result_lengthplot <- final_result %>% mutate(result=ifelse(prediction=="unclassified" & result!="no category","unclassified",result))
level_order_results <- c("TP","TN","FP","FN","unclassified","no category")
ggplot(final_result_lengthplot,aes(x=log(contig_length,10),fill=factor(result, level= level_order_results)))+
  geom_histogram(binwidth = 0.2, boundary=0)+
  scale_fill_manual(labels=c("TP","TN","FP","FN","No category"),values=c("#47954D","#75C24B","#B94B33","#FA6C4D","#FACE1B","#868686"))+
  labs(title="Predictions according to contig length",x = "Contig length (log10 bp)", y = "Count",fill="Result")+
  facet_wrap(~software,labeller = labeller(software=c("mlplasmids"="Mlplasmids","platon"="Platon","plascope"="PlaScope","rfplasmid"="RFPlasmid")))
```

### Combining multiple softwares
We are also interested in whether combining the outputs of multiple binary classifiers into an ensemble classifier improves our results.
We can explore which contigs are differentially predicted by different softwares using Venn diagrams.  
For PlaScope, we again categorise 'unclassified' contigs as chromosome.

Build Venn diagrams
```{r}
#Make a list of all true positives per software
list_TP <- list(mlplasmids = true_positives %>% filter(software=='mlplasmids') %>% pull(contig_name),Platon =true_positives %>% filter(software=='platon') %>% pull(contig_name),PlaScope=true_positives %>% filter(software=='plascope') %>% pull(contig_name),RFPlasmid=true_positives %>% filter(software=='rfplasmid') %>% pull(contig_name))
#Convert list to venn diagram
VennTP <- venn.diagram(list_TP,filename = NULL,fill=brewer.pal(4, "Set3"))
```

```{r}
list_TN <- list(mlplasmids = true_negatives %>% filter(software=='mlplasmids') %>% pull(contig_name),Platon =true_negatives %>% filter(software=='platon') %>% pull(contig_name),PlaScope=true_negatives %>% filter(software=='plascope') %>% pull(contig_name),RFPlasmid=true_negatives %>% filter(software=='rfplasmid') %>% pull(contig_name))
VennTN<- venn.diagram(list_TN,filename = NULL,fill=brewer.pal(4, "Set3"))
```

```{r}
list_FP <- list(mlplasmids = false_positives %>% filter(software=='mlplasmids') %>% pull(contig_name),Platon =false_positives %>% filter(software=='platon') %>% pull(contig_name),PlaScope=false_positives %>% filter(software=='plascope') %>% pull(contig_name),RFPlasmid=false_positives %>% filter(software=='rfplasmid') %>% pull(contig_name))
VennFP<- venn.diagram(list_FP,filename = NULL,fill=brewer.pal(4, "Set3"))
```

```{r}
list_FN <- list(mlplasmids = false_negatives %>% filter(software=='mlplasmids') %>% pull(contig_name),Platon =false_negatives %>% filter(software=='platon') %>% pull(contig_name),PlaScope=false_negatives %>% filter(software=='plascope') %>% pull(contig_name),RFPlasmid=false_negatives %>% filter(software=='rfplasmid') %>% pull(contig_name))
VennFN<- venn.diagram(list_FN,filename = NULL,fill=brewer.pal(4, "Set3"))
```

Try out an upset plot instead

```{r}
#merge false positives and false negatives
df_FP <- fromList(list_FP) %>% mutate(type="FP")
df_FN <- fromList(list_FN) %>% mutate(type="FN")
df_false <- rbind(df_FP,df_FN)
```

```{r}
#pdf(file = "../results/figures/upset_false.pdf",width = 10,height = 7)
upset(df_false,sets = rev(c("mlplasmids","PlaScope","Platon","RFPlasmid")), order.by = "freq",keep.order = TRUE, queries = list(list(query = elements, params = list("type","FN","FP"), color = "dark orange", active = T,query.name = "False Negative"),list(query = elements, params = list("type","FP"), color = "red", active = T,query.name = "False Positive")),query.legend = "top")
#dev.off()
```

```{r}
png(file = "../results/figures/upset2_FP.png",width = 20,height = 14,units = "cm",res = 200)
upset(df_FP,sets = rev(c("mlplasmids","PlaScope","Platon","RFPlasmid")), order.by = "freq",keep.order = TRUE, queries = list(list(query = intersects, params = list("mlplasmids","Platon","PlaScope"), color = "orange", active = T),list(query = intersects, params = list("mlplasmids","PlaScope","RFPlasmid"), color = "orange", active = T),list(query = intersects, params = list("RFPlasmid","Platon","PlaScope"), color = "orange", active = T),list(query = intersects, params = list("mlplasmids","RFPlasmid","Platon"), color = "orange", active = T),list(query = intersects, params = list("mlplasmids"), color = "blue", active = T),list(query = intersects, params = list("Platon"), color = "blue", active = T),list(query = intersects, params = list("PlaScope"), color = "blue", active = T),list(query = intersects, params = list("RFPlasmid"), color = "blue", active = T)))
dev.off()
```
```{r}
png(file = "../results/figures/upset2_FN.png",width = 20,height = 14,units = "cm",res = 200)
upset(df_FN,sets = rev(c("mlplasmids","PlaScope","Platon","RFPlasmid")), order.by = "freq",keep.order = TRUE, queries = list(list(query = intersects, params = list("mlplasmids","Platon","PlaScope"), color = "orange", active = T),list(query = intersects, params = list("mlplasmids","PlaScope","RFPlasmid"), color = "orange", active = T),list(query = intersects, params = list("RFPlasmid","Platon","PlaScope"), color = "orange", active = T),list(query = intersects, params = list("mlplasmids","RFPlasmid","Platon"), color = "orange", active = T),list(query = intersects, params = list("mlplasmids"), color = "blue", active = T),list(query = intersects, params = list("Platon"), color = "blue", active = T),list(query = intersects, params = list("PlaScope"), color = "blue", active = T),list(query = intersects, params = list("RFPlasmid"), color = "blue", active = T)))
dev.off()
```
Show true positives

```{r}
df_TP <- fromList(list_TP) %>% mutate(type="TP")
df_TN <- fromList(list_TN) %>% mutate(type="TN")
```

```{r}
png(file = "../results/figures/upset2_TP.png",width = 20,height = 14,units = "cm",res = 200)
upset(df_TP,sets = rev(c("mlplasmids","PlaScope","Platon","RFPlasmid")), order.by = "freq",keep.order = TRUE, queries = list(list(query = intersects, params = list("mlplasmids","Platon","PlaScope"), color = "orange", active = T),list(query = intersects, params = list("mlplasmids","PlaScope","RFPlasmid"), color = "orange", active = T),list(query = intersects, params = list("RFPlasmid","Platon","PlaScope"), color = "orange", active = T),list(query = intersects, params = list("mlplasmids","RFPlasmid","Platon"), color = "orange", active = T),list(query = intersects, params = list("mlplasmids"), color = "blue", active = T),list(query = intersects, params = list("Platon"), color = "blue", active = T),list(query = intersects, params = list("PlaScope"), color = "blue", active = T),list(query = intersects, params = list("RFPlasmid"), color = "blue", active = T)))
dev.off()
```
```{r}
#pdf(file = "../results/figures/upset_TP.pdf",width = 10,height = 7)
upset(df_TP,sets = rev(c("mlplasmids","PlaScope","Platon","RFPlasmid")), order.by = "freq",keep.order = TRUE, queries = list(list(query = elements, params = list("type","TP"), color = "dark green", active = T)))
#dev.off()
```

```{r}
png(file = "../results/figures/upset2_TN.png",width = 20,height = 14,units = "cm",res = 200)
upset(df_TN,sets = rev(c("mlplasmids","PlaScope","Platon","RFPlasmid")), order.by = "freq",keep.order = TRUE, queries = list(list(query = intersects, params = list("mlplasmids","Platon","PlaScope"), color = "orange", active = T),list(query = intersects, params = list("mlplasmids","PlaScope","RFPlasmid"), color = "orange", active = T),list(query = intersects, params = list("RFPlasmid","Platon","PlaScope"), color = "orange", active = T),list(query = intersects, params = list("mlplasmids","RFPlasmid","Platon"), color = "orange", active = T),list(query = intersects, params = list("mlplasmids"), color = "blue", active = T),list(query = intersects, params = list("Platon"), color = "blue", active = T),list(query = intersects, params = list("PlaScope"), color = "blue", active = T),list(query = intersects, params = list("RFPlasmid"), color = "blue", active = T)))
dev.off()
```

Exclude the four-way intersection
```{r}
df_TN_excluded <- fromList(list_TN) %>% filter(rowSums(.)<4) %>% mutate(type="TN")
```

```{r}
pdf(file = "../results/figures/upset2_TN_excl.pdf",width = 10,height = 7)
upset(df_TN_excluded,sets = rev(c("mlplasmids","PlaScope","Platon","RFPlasmid")), order.by = "freq",keep.order = TRUE, queries = list(list(query = intersects, params = list("mlplasmids","Platon","PlaScope"), color = "orange", active = T),list(query = intersects, params = list("mlplasmids","PlaScope","RFPlasmid"), color = "orange", active = T),list(query = intersects, params = list("RFPlasmid","Platon","PlaScope"), color = "orange", active = T),list(query = intersects, params = list("mlplasmids","RFPlasmid","Platon"), color = "orange", active = T),list(query = intersects, params = list("mlplasmids"), color = "blue", active = T),list(query = intersects, params = list("Platon"), color = "blue", active = T),list(query = intersects, params = list("PlaScope"), color = "blue", active = T),list(query = intersects, params = list("RFPlasmid"), color = "blue", active = T)))
dev.off()
```
Use log scale

```{r}
pdf(file = "../results/figures/upset2_TN_log.pdf",width = 10,height = 7)
upset(df_TN,sets = rev(c("mlplasmids","PlaScope","Platon","RFPlasmid")), scale.intersections = "log10", scale.sets = "log10", order.by = "freq",keep.order = TRUE)
dev.off()
```

```{r,echo=FALSE}
cowplot::plot_grid(VennTP,VennTN,labels = c("True Positives","True Negatives"),label_x = 0.1)
cowplot::plot_grid(VennFP,VennFN,labels = c("False Positives","False Negatives"),label_x = 0.1)
```
These diagrams show that false positives and false negatives are often misclassified by only one of the softwares, while the other softwares classify them correctly. Besides, a significant portion of true positives and true negatives is correctly identified by two or three, but not all of the tools.

```{r}
ggsave("../results/figures/venn_false.svg",width = 10, height =6)
```

We now explore what happens when we combine three of the softwares, and assume the classification that the majority of softwares call.  

Count the number of contigs at the intersections of the resulting venn diagrams (not drawn). For example, for all true positive contigs we count which tool or combination of tools categorised them as true positive. We do this for all results, and merge the files.
```{r,fig.show='hide'}
venn_counts_TP <- as_tibble(as.list(lengths(attributes(venn(venn_TP))$intersections)))
venn_counts_FP <- as_tibble(as.list(lengths(attributes(venn(venn_FP))$intersections)))
venn_counts_TN <- as_tibble(as.list(lengths(attributes(venn(venn_TN))$intersections)))
venn_counts_FN <- as_tibble(as.list(lengths(attributes(venn(venn_FN))$intersections)))
venn_counts <- rbind(venn_counts_TP,venn_counts_TN,venn_counts_FP,venn_counts_FN)
venn_counts %<>% replace(is.na(.), 0)
```

Calculate by how many tools each result is achieved.
I use regex patterns for selecting the column names with either just one ':' or two ':'s, the  pattern can be explained this way:
^ beginning of line
[^:]* all characters except ':'
$ end of line
```{r}
tool_numbers <- venn_counts %>% mutate(one_tool=rowSums(venn_counts %>% select(c("Mlplasmids","Platon","PlaScope","RFPlasmid"))),two_tools=rowSums(venn_counts %>% select(matches('^[^:]*:[^:]*$'))),three_tools=rowSums(venn_counts %>% select(matches('^[^:]*:[^:]*:[^:]*$'))),all_tools=`Mlplasmids:Platon:PlaScope:RFPlasmid`) %>% select(one_tool,two_tools,three_tools,all_tools) %>%mutate(total=rowSums(.))
```
```{r}
tool_numbers
```

We calculate the number of true positive, true negative, false positive and false negative contigs for each of the four combinations of softwares. Contig predictions are included if they are given by at least two out of three softwares. This means that predictions by three of four softwares are always included.
```{r}
for (combination in c("Mlplasmids/Platon/PlaScope","Mlplasmids/Platon/RFPlasmid","Mlplasmids/PlaScope/RFPlasmid","Platon/PlaScope/RFPlasmid")){
  #Split the input names into variables soft1/soft2/soft3
  softwares <- unlist(str_split(combination,'/'))
  i<-1
  for (software in softwares){
    assign(paste("soft",i,sep=""),software)
    i<-i+1
  }
  #For each column in venn_counts2 it is evaluated whether it is included in the final result.
  #This is the case if it contains three or four softwares in total, or two of the input softwares (soft1 + soft2, soft1 + soft3 or soft2 + soft3)
  pattern<-paste(":.*:|",soft1,":",soft2,"|",soft1,":",soft3,"|",soft2,":",soft3,sep = "")
  #The row sum of these columns is added as a new column named after the software combination
  venn_counts$new_column <- rowSums(venn_counts[grepl(pattern,colnames(venn_counts))])
  names(venn_counts)[names(venn_counts) == "new_column"] <- combination
}
```

Calculate precision, recall and F1-score for the ensemble combinations.
```{r}
venn_scores <- venn_counts %>% select(`Mlplasmids/PlaScope/RFPlasmid`,`Mlplasmids/Platon/PlaScope`,`Mlplasmids/Platon/RFPlasmid`,`Platon/PlaScope/RFPlasmid`)
venn_scores <- as.data.frame(t(venn_scores))
venn_scores %<>% rename(c(TP = V1,TN = V2,FP = V3,FN = V4))
rownames(venn_scores) <- str_replace(row.names(venn_scores),"Total_","")
venn_scores %<>% mutate(precision=TP/(TP+FP),recall=TP/(TP+FN),f1_score=2*(precision*recall)/(precision+recall))
venn_scores %<>% rownames_to_column("Combination")
```

```{r,echo=FALSE}
venn_scores %>% flextable()
#caption = "Performance of ensemble classifiers (calculated per contig)")
```
Plot all metrics, for individual and ensemble classifiers:

```{r}
metrics_plotting_data <- rbind(venn_scores %>% rename(software=Combination) ,count_results %>% select(!"no category"))
metrics_plotting_data %<>% pivot_longer(precision:f1_score, names_to = "metric", values_to = "value")

metrics_levels <- c('recall','precision','f1_score')
software_levels <- c("mlplasmids","plascope","platon","rfplasmid","Mlplasmids/Platon/PlaScope","Mlplasmids/PlaScope/RFPlasmid","Mlplasmids/Platon/RFPlasmid","Platon/PlaScope/RFPlasmid")
```


```{r}
ggplot(metrics_plotting_data,aes(y=factor(software,level = rev(software_levels)),x=value))+
  geom_point(size=2,aes(colour=factor(metric,level = metrics_levels)))+
  labs(title="Performance of binary and ensemble classifiers",y="Classifier",x="Score",colour="Metric")+
  scale_colour_manual(labels=c("Recall","Precision","F1-Score"),values=c("#4c7af2","#f2924c","#f24c76"))+
  scale_y_discrete(labels=rev(c("mlplasmids","PlaScope","Platon","RFPlasmid","mlplasmids/PlaScope/Platon","mlplasmids/PlaScope/RFPlasmid","mlplasmids/Platon/RFPlasmid","Platon/PlaScope/RFPlasmid")))+
  xlim(0.69,1)+
  geom_hline(yintercept=4.5,colour="#8b8b8c")+
  theme(plot.title = element_text(size = 12))
```

```{r}
ggsave("../results/figures/result_overall.svg",width = 8, height = 2.5)
```

Furthermore, we can take a look at the length of the false positive and false negative contigs that are called by the ensemble classifiers. We want to avoid large contigs being misclassified.

Get the contig names of the false positives and false negatives for each ensemble classifier
```{r,fig.show='hide'}
#Get the contig names of false negatives and false postives grouped by software combination
venn_contigs_FN <- attributes(venn(venn_FN))$intersections
venn_contigs_FP <- attributes(venn(venn_FP))$intersections
venn_contigs_TN <- attributes(venn(venn_TN))$intersections
venn_contigs_TP <- attributes(venn(venn_TP))$intersections

lengths_contigs_ensembles <- as_tibble(data.frame())
for (combination in c("Mlplasmids/Platon/PlaScope","Mlplasmids/Platon/RFPlasmid","Mlplasmids/PlaScope/RFPlasmid","Platon/PlaScope/RFPlasmid")){
  #Split the input names into variables soft1/soft2/soft3
  softwares <- unlist(str_split(combination,'/'))
  i<-1
  for (software in softwares){
    assign(paste("soft",i,sep=""),software)
    i<-i+1
  }
  #Apply same pattern as before for column selection
  pattern<-paste(":.*:|",soft1,":",soft2,"|",soft1,":",soft3,"|",soft2,":",soft3,sep = "")
  columns <- colnames(venn_counts[grepl(pattern,colnames(venn_counts))])
  file_FP <- as_tibble(data.frame())
  file_FN <- as_tibble(data.frame())
  file_TP <- as_tibble(data.frame())
  file_TN <- as_tibble(data.frame())
  #Rbind all contigs in those columns to intermediate files file_FP and file_FN
  for (column in columns){
    file_FP <- rbind(file_FP,as_tibble(venn_contigs_FP[[column]]))
    file_FN <- rbind(file_FN,as_tibble(venn_contigs_FN[[column]]))
    file_TP <- rbind(file_TP,as_tibble(venn_contigs_TP[[column]]))
    file_TN <- rbind(file_TN,as_tibble(venn_contigs_TN[[column]]))
  }
  #Add result and combination names
  file_FN %<>% mutate(result="FN",combination=combination)
  file_FP %<>% mutate(result="FP",combination=combination)
  file_TP %<>% mutate(result="TP",combination=combination)
  file_TN %<>% mutate(result="TN",combination=combination)
  #Append output file
  lengths_contigs_ensembles <- rbind(lengths_contigs_ensembles,file_FN,file_FP,file_TN,file_TP)
}
```

Calculate contig length
```{r}
lengths_contigs_ensembles %<>% rename(contig_name=value) %>% mutate(contig_length=as.numeric(sub(".*?length_(.*?)_.*", "\\1",contig_name)))
```

Metrics per bp
```{r}
count_ensemble_lengths <- lengths_contigs_ensembles %>% group_by(combination,result) %>% summarise(total_bp = sum(contig_length)) %>% spread(result,total_bp) %>% mutate(precision=TP/(TP+FP),recall=TP/(TP+FN),f1_score=2*(precision*recall)/(precision+recall))
count_ensemble_lengths %>% flextable()
#caption = "Performance of ensemble classifiers (calculated per basepair)")
```


```{r,message=FALSE}
ggplot(lengths_contigs_ensembles,aes(x=log(contig_length,10),fill=factor(result, level= level_order_results)))+
  geom_histogram(binwidth = 0.2, boundary=0)+
  scale_fill_manual(labels=c("TP","TN","FP","FN","No category"),values=c("#47954D","#75C24B","#B94B33","#FA6C4D","#FACE1B","#868686"))+
  labs(title="Predictions according to contig length",x = "Contig length (log10 bp)", y = "Count",fill="Result")+
  facet_wrap(~combination)
```

## Analysis for AMR containing replicons

Import AMR containing plasmid info, delete any strains that are not in the base dataset.
```{r}
AMR_replicons <- read.csv("../../binary_classifiers/results/arg_plasmids.csv", header = TRUE)
names(AMR_replicons) <- c("assembly_accession","replicon_name","atbr_count")
all_strains <- sub("_2021.*","\\1",all_contigs$contig_name)
AMR_replicons %<>% filter(assembly_accession %in% all_strains)
```

For every AMR replicon we find the corresponding contig information.
```{r}
AMR_contig_info <- right_join(selected_contig_info,AMR_replicons)
```

From the binary classifier output we select all contigs that belong to an AMR plasmid. We disregard contigs that have no alignments, because we don't know whether they belong to an AMR plasmid.
```{r}
AMR_analysis<- right_join(all_output,AMR_contig_info,by="contig_name")
```

The rest of the analysis is the same as before, just with a smaller dataset.
We now only have information about recall (true positives and false negatives) because there are only plasmids in this dataset.
```{r}
true_positives_AMR <- AMR_analysis %>% filter(prediction=="plasmid" & classification=="plasmid") %>% mutate(result="TP")
false_negatives_AMR <- AMR_analysis %>% filter((prediction=="chromosome" | prediction=="unclassified")& classification=="plasmid") %>% mutate(result="FN")
```

Bind together in final result file.  
A column with the contig length is added to the dataset.
```{r,warning=FALSE}
final_result_AMR <- rbind(true_positives_AMR,false_negatives_AMR)
final_result_AMR %<>% mutate(contig_length=as.numeric(sub(".*?length_(.*?)_.*", "\\1",contig_name)))
```

Calculate metrics
```{r,message=FALSE}
count_results_AMR <- final_result_AMR %>% group_by(software) %>% count(result)
count_results_AMR %<>% spread(result,n) %>% mutate(recall=TP/(TP+FN))
count_results_AMR %>% select(TP,FN,recall) %>% flextable()
      #caption = "Performance of binary classifiers (calculated per contig)")
```

```{r}
ggsave("binary_comparison.png",height = 5, width = 8)
```

Instead of calculating the metrics for each contig, we can also assess the total number of basepairs that a software identifies as correct/incorrect.
Because longer contigs are easier to categorise, this leads to more favourable results.

```{r,message=FALSE}
length_result_AMR <- final_result_AMR %>% group_by(software,result) %>% summarise(total_bp = sum(contig_length))
count_lengths_AMR <- spread(length_result_AMR,result,total_bp) %>% mutate(recall=TP/(TP+FN))
count_lengths_AMR %>% select(TP,FN,recall) %>% flextable() #caption = "Performance of binary classifiers (calculated per basepair)")
```


```{r,echo=FALSE,message=FALSE,fig.height=7}
final_result_lengthplot_AMR <- final_result_AMR %>% mutate(result=ifelse(prediction=="unclassified" & result!="no category","unclassified",result))
level_order_results_AMR <- c("TP","FN","unclassified")
ggplot(final_result_lengthplot_AMR,aes(x=log(contig_length,10),fill=factor(result, level= level_order_results_AMR)))+
  geom_histogram(binwidth = 0.2, boundary=0)+
  scale_fill_manual(labels=c("TP","FN","unclassified"),values=c("#47954D","#FA6C4D","#FACE1B"))+
  labs(title="Predictions according to contig length",x = "Contig length (log10 bp)", y = "Count",fill="Result")+
  facet_wrap(~software,labeller = labeller(software=c("mlplasmids"="Mlplasmids","platon"="Platon","plascope"="PlaScope","rfplasmid"="RFPlasmid")))
```

### Combining multiple softwares
We are also interested in whether combining the outputs of multiple binary classifiers into an ensemble classifier improves our results.
We can explore which contigs are differentially predicted by different softwares using Venn diagrams.  
For PlaScope, we again categorise 'unclassified' contigs as chromosome.

Build Venn diagrams
```{r}
#Make a list of all true positives per software
venn_TP_AMR <- list(Mlplasmids = true_positives_AMR %>% filter(software=='mlplasmids') %>% pull(contig_name),Platon =true_positives_AMR %>% filter(software=='platon') %>% pull(contig_name),PlaScope=true_positives_AMR %>% filter(software=='plascope') %>% pull(contig_name),RFPlasmid=true_positives_AMR %>% filter(software=='rfplasmid') %>% pull(contig_name))
#Convert list to venn diagram
VennTP_AMR <- venn.diagram(venn_TP_AMR,filename = NULL,fill=brewer.pal(4, "Set3"))
```

```{r}
venn_FN_AMR <- list(Mlplasmids = false_negatives_AMR %>% filter(software=='mlplasmids') %>% pull(contig_name),Platon =false_negatives_AMR %>% filter(software=='platon') %>% pull(contig_name),PlaScope=false_negatives_AMR %>% filter(software=='plascope') %>% pull(contig_name),RFPlasmid=false_negatives_AMR %>% filter(software=='rfplasmid') %>% pull(contig_name))
VennFN_AMR<- venn.diagram(venn_FN_AMR,filename = NULL,fill=brewer.pal(4, "Set3"))
```

```{r,echo=FALSE}
cowplot::plot_grid(VennTP_AMR,VennFN_AMR,labels = c("True Positives","False Negatives"),label_x = 0.1)
```
These diagrams show that false positives and false negatives are often misclassified by only one of the softwares, while the other softwares classify them correctly. Besides, a significant portion of true positives and true negatives is correctly identified by two or three, but not all of the tools.

We now explore what happens when we combine three of the softwares, and assume the classification that the majority of softwares call.  

Count the number of contigs at the intersections of the resulting venn diagrams (not drawn). For example, for all true positive contigs we count which tool or combination of tools categorised them as true positive. We do this for all results, and merge the files.
```{r,fig.show='hide'}
venn_counts_TP_AMR <- as_tibble(as.list(lengths(attributes(venn(venn_TP_AMR))$intersections)))
venn_counts_FN_AMR <- as_tibble(as.list(lengths(attributes(venn(venn_FN_AMR))$intersections)))
venn_counts_AMR <- merge(venn_counts_TP_AMR,venn_counts_FN_AMR,all = TRUE)
venn_counts_AMR %<>% replace(is.na(.), 0)
rownames(venn_counts_AMR) <- c("TP","FN")
```

We calculate the number of true positive, true negative, false positive and false negative contigs for each of the four combinations of softwares. Contig predictions are included if they are given by at least two out of three softwares. This means that predictions by three of four softwares are always included.
```{r}
for (combination in c("Mlplasmids/Platon/PlaScope","Mlplasmids/Platon/RFPlasmid","Mlplasmids/PlaScope/RFPlasmid","Platon/PlaScope/RFPlasmid")){
  #Split the input names into variables soft1/soft2/soft3
  softwares <- unlist(str_split(combination,'/'))
  i<-1
  for (software in softwares){
    assign(paste("soft",i,sep=""),software)
    i<-i+1
  }
  #For each column in venn_counts2 it is evaluated whether it is included in the final result.
  #This is the case if it contains three or four softwares in total, or two of the input softwares (soft1 + soft2, soft1 + soft3 or soft2 + soft3)
  pattern<-paste(":.*:|",soft1,":",soft2,"|",soft1,":",soft3,"|",soft2,":",soft3,sep = "")
  #The row sum of these columns is added as a new column named after the software combination
  venn_counts_AMR$new_column <- rowSums(venn_counts_AMR[grepl(pattern,colnames(venn_counts_AMR))])
  names(venn_counts_AMR)[names(venn_counts_AMR) == "new_column"] <- combination
}
```

Calculate recall for the ensemble combinations.
```{r}
venn_scores_AMR <- venn_counts_AMR %>% select(`Mlplasmids/PlaScope/RFPlasmid`,`Mlplasmids/Platon/PlaScope`,`Mlplasmids/Platon/RFPlasmid`,`Platon/PlaScope/RFPlasmid`)
venn_scores_AMR <- as.data.frame(t(venn_scores_AMR))
rownames(venn_scores_AMR) <- str_replace(row.names(venn_scores_AMR),"Total_","")
venn_scores_AMR %<>% mutate(recall=TP/(TP+FN))
venn_scores_AMR %<>% rownames_to_column("Combination")
```

```{r,echo=FALSE}
venn_scores_AMR %>% flextable()
#caption = "Performance of ensemble classifiers (calculated per contig)")
```

Furthermore, we can take a look at the length of the false positive and false negative contigs that are called by the ensemble classifiers. We want to avoid large contigs being misclassified.

Get the contig names of the false positives and false negatives for each ensemble classifier
```{r,fig.show='hide'}
#Get the contig names of false negatives and false postives grouped by software combination
venn_contigs_FN_AMR <- attributes(venn(venn_FN_AMR))$intersections
venn_contigs_TP_AMR <- attributes(venn(venn_TP_AMR))$intersections

lengths_contigs_ensembles_AMR <- as_tibble(data.frame())
for (combination in c("Mlplasmids/Platon/PlaScope","Mlplasmids/Platon/RFPlasmid","Mlplasmids/PlaScope/RFPlasmid","Platon/PlaScope/RFPlasmid")){
  #Split the input names into variables soft1/soft2/soft3
  softwares <- unlist(str_split(combination,'/'))
  i<-1
  for (software in softwares){
    assign(paste("soft",i,sep=""),software)
    i<-i+1
  }
  #Apply same pattern as before for column selection
  pattern<-paste(":.*:|",soft1,":",soft2,"|",soft1,":",soft3,"|",soft2,":",soft3,sep = "")
  columns <- colnames(venn_counts_AMR[grepl(pattern,colnames(venn_counts_AMR))])
  file_TP <- as_tibble(data.frame())
  file_FN <- as_tibble(data.frame())
  #Rbind all contigs in those columns to intermediate files file_FP and file_FN
  for (column in columns){
    file_FN <- rbind(file_FN,as_tibble(venn_contigs_FN_AMR[[column]]))
    file_TP <- rbind(file_TP,as_tibble(venn_contigs_TP_AMR[[column]]))
  }
  #Add result and combination names
  file_FN %<>% mutate(result="FN",combination=combination)
  file_TP %<>% mutate(result="TP",combination=combination)
  
  #Append output file
  lengths_contigs_ensembles_AMR <- rbind(lengths_contigs_ensembles_AMR,file_FN,file_TP)
}
```

Calculate contig length
```{r}
lengths_contigs_ensembles_AMR %<>% rename(contig_name=value) %>% mutate(contig_length=as.numeric(sub(".*?length_(.*?)_.*", "\\1",contig_name)))
```

Metrics per bp
```{r}
count_ensemble_lengths_AMR <- lengths_contigs_ensembles_AMR %>% group_by(combination,result) %>% summarise(total_bp = sum(contig_length)) %>% spread(result,total_bp) %>% mutate(recall=TP/(TP+FN))
count_ensemble_lengths_AMR %>% flextable()
#caption = "Performance of ensemble classifiers (calculated per basepair)")
```


```{r,message=FALSE}
ggplot(lengths_contigs_ensembles_AMR,aes(x=log(contig_length,10),fill=factor(result, level= level_order_results_AMR)))+
  geom_histogram(binwidth = 0.2, boundary=0)+
  scale_fill_manual(labels=c("TP","FN","unclassified"),values=c("#47954D","#FA6C4D","#FACE1B"))+
  facet_wrap(~combination)+
  labs(title="Predictions according to contig length",x = "Contig length (log10 bp)", y = "Count",fill="Result")
```

```{r}
metrics_plotting_data_AMR <- rbind(venn_scores_AMR %>% rename(software=Combination) ,count_results_AMR)
```

```{r}
ggplot(metrics_plotting_data_AMR,aes(y=factor(software,level = rev(software_levels)),x=recall))+
  geom_point(size=3,colour="#4c7af2")+
  labs(title="Recall of binary and ensemble classifiers for plasmids containing AMR genes",y="Classifier",x="Recall")+
  scale_colour_manual(labels=c("Recall","Precision","F1-Score"),values=c("#4c7af2","#f2924c","#f24c76"))+
  scale_y_discrete(labels=rev(c("mlplasmids","PlaScope","Platon","RFPlasmid","mlplasmids/PlaScope/Platon","mlplasmids/PlaScope/RFPlasmid","mlplasmids/Platon/RFPlasmid","Platon/PlaScope/RFPlasmid")))+
  xlim(0.69,1)+
  geom_hline(yintercept=4.5,colour="#8b8b8c")+
  theme(plot.title = element_text(size = 12))
```

```{r}
#group classifiers by ensemble or individual, based on if software contains a '/'
metrics_plotting_data %<>% mutate(group=ifelse(grepl('/',software),'ensemble','individual'))
metrics_plotting_data_AMR %<>% mutate(group=ifelse(grepl('/',software),'ensemble','individual'))
```

### Plot all metrics into one graph

```{r}
plot_ind <- ggplot(metrics_plotting_data %>% filter(group=="individual"),aes(y=factor(software,level = rev(software_levels)),x=value))+
  geom_point(size=3,aes(colour=factor(metric,level = metrics_levels)))+
  labs(title="Performance of binary classifiers (full dataset)",y=NULL,x=NULL,colour="Metric")+
  scale_colour_manual(labels=c("Recall","Precision","F1-Score"),values=c("#4c7af2","#f2924c","#f24c76"))+
  scale_y_discrete(labels=rev(c("mlplasmids","PlaScope","Platon","RFPlasmid")))+
  xlim(0.69,1)+
  theme(plot.title = element_text(size = 12))
```

```{r}
plot_ens <- ggplot(metrics_plotting_data %>% filter(group=="ensemble"),aes(y=factor(software,level = rev(software_levels)),x=value))+
  geom_point(size=3,aes(colour=factor(metric,level = metrics_levels)))+
  labs(title="Performance of plasmidEC (full dataset)",y=NULL,x="Score",colour="Metric")+
  scale_colour_manual(labels=c("Recall","Precision","F1-Score"),values=c("#4c7af2","#f2924c","#f24c76"))+
  scale_y_discrete(labels=rev(c("mlplasmids/PlaScope/Platon","mlplasmids/PlaScope/RFPlasmid","mlplasmids/Platon/RFPlasmid","Platon/PlaScope/RFPlasmid")))+
  xlim(0.69,1)+
  theme(plot.title = element_text(size = 12))
```

```{r}
plot_ind_AMR <- ggplot(metrics_plotting_data_AMR %>% filter(group=="individual"),aes(y=factor(software,level = rev(software_levels)),x=recall))+
  geom_point(size=3,colour="#4c7af2")+
  labs(title="Performance of binary classifiers (resistance plasmids)",y= NULL,x=NULL)+
  xlim(0.69,1)+
  theme(plot.title = element_text(size = 12),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
```

```{r}
plot_ens_AMR <- ggplot(metrics_plotting_data_AMR %>% filter(group=="ensemble"),aes(y=factor(software,level = rev(software_levels)),x=recall))+
  geom_point(size=3,colour="#4c7af2")+
  labs(title="Performance of plasmidEC (resistance plasmids)",y= NULL,x="Score")+
  xlim(0.69,1)+
  theme(plot.title = element_text(size = 12),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
```

```{r}
metrics_levels <- c('recall','precision','f1_score')
```

```{r}
plot_ind+plot_ind_AMR+plot_ens+plot_ens_AMR+
  plot_annotation(tag_levels = 'A')+
  plot_layout(guides = 'collect') & theme(legend.position='bottom')
```

```{r}
ggsave("../results/figures/all_metrics.png",width = 10, height = 5)
```

Why is there an increase in performance for AMR containing plasmids? A possible explanation would be that the contigs are larger on average, making it easier to classify them.

```{r}
plasmid_length_data <- rbind(final_result %>% filter(classification=="plasmid") %>% select(contig_length) %>% mutate(dataset="full"),final_result_AMR %>% select(contig_length) %>% mutate(dataset="AMR plasmids"))

ggplot(plasmid_length_data,aes(x=dataset,y=log(contig_length,10)))+
  geom_boxplot()
```

Hmm actually the full dataset has a slightly larger median contig length, so this is not the right explanation.

### Compare cpu and memory requirements

Import cpu and memory data
```{r}
comp_data <- read_delim("../../binary_classifiers/results/cpu_memory_records.txt"," ")
#remove whitespace in column names and data
names(comp_data)<-gsub(" ", "",names(comp_data))
comp_data %<>% mutate_if(is.character, str_trim)
#add software names according to JobID
comp_data %<>% mutate(tool=c("mlplasmids","Platon","PlaScope","RFPlasmid","mlplasmids/PlaScope/Platon","mlplasmids/Platon/RFPlasmid","mlplasmids/PlaScope/RFPlasmid","PlaScope/Platon/RFPlasmid"))
```

Move days, hours, minutes into separate columns
```{r}
comp_data %<>% separate(CPUTime,c("days","hms"),sep = '-',remove = FALSE,fill = 'left')
comp_data %<>% separate(hms,c("hours","minutes","seconds"),sep = ":",remove = FALSE)
#convert time columns from character to numeric
comp_data %<>% mutate_at(c("days","hours","minutes","seconds"),as.numeric)
#convert na values to zero
comp_data[is.na(comp_data)] <- 0
```

Convert time to minutes
```{r}
comp_data %<>% mutate(cpu_mins=1440*days+60*hours+minutes+seconds/60)
```

Convert memory to MB
```{r}
#convert value to numeric
comp_data %<>% mutate(memory_mb=as.numeric(sub("K","",MaxRSS)))
#convert to mb
comp_data %<>% mutate(memory_mb=memory_mb/1000)
```

Calculate avg time and memory per sample
```{r}
comp_data %<>% mutate(avg_time=60*cpu_mins/213) %>% mutate(avg_mem=memory_mb/213)
```

```{r}
tool_levels<- c("mlplasmids","PlaScope","Platon","RFPlasmid","mlplasmids/PlaScope/Platon","mlplasmids/PlaScope/RFPlasmid","mlplasmids/Platon/RFPlasmid","PlaScope/Platon/RFPlasmid")
time <- ggplot(comp_data,aes(x=avg_time,y=factor(tool,level=rev(tool_levels))))+
  geom_bar(stat = "identity")+
  labs(x="Average CPU time per sample (mins)",y=NULL)
```

```{r}
tool_levels<- c("mlplasmids","PlaScope","Platon","RFPlasmid","mlplasmids/PlaScope/Platon","mlplasmids/PlaScope/RFPlasmid","mlplasmids/Platon/RFPlasmid","PlaScope/Platon/RFPlasmid")
mem <- ggplot(comp_data,aes(x=avg_mem,y=factor(tool,level=rev(tool_levels))))+
  geom_bar(stat = "identity")+
  labs(x="Average memory per sample (MB)",y=NULL)+
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank())
```

```{r}
time+mem+
  plot_annotation(tag_levels = 'A')
```

```{r}
ggsave("../results/figures/cpu.svg",width = 8, height = 3)
```
